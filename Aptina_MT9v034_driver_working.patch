diff --git a/linux-3.4/arch/arm/mach-sunxi/sun8i.c b/linux-3.4/arch/arm/mach-sunxi/sun8i.c
index 7700d04..6fa9ce6 100755
--- a/linux-3.4/arch/arm/mach-sunxi/sun8i.c
+++ b/linux-3.4/arch/arm/mach-sunxi/sun8i.c
@@ -42,6 +42,9 @@
 #include <mach/sunxi-chip.h>
 #include <mach/sunxi-smc.h>
 
+//ankt
+#include <media/mt9v032.h>
+
 #ifdef CONFIG_SMP
 extern struct smp_operations sunxi_smp_ops;
 #endif
@@ -117,6 +120,29 @@ static struct i2c_board_info i2c_ina219_devs[] __initdata = {
 };
 #endif
 
+//ankt
+#define APTINA_SENSOR_I2C_ENABLE
+#if defined(APTINA_SENSOR_I2C_ENABLE)
+#define APTINA_SENSOR_I2C_BUS     (2)
+
+static const s64 mt9v034_link_freqs[] = {
+	13000000,
+	26600000,
+	27000000,
+	0,
+};
+static struct mt9v032_platform_data my_mt9v034_platform_data = {
+	.clk_pol	= 0,
+	.link_freqs	= mt9v034_link_freqs,
+	.link_def_freq	= 26600000,
+};
+
+static struct i2c_board_info __initdata aptina_sensor_i2c_bdi = {
+               I2C_BOARD_INFO("mt9v032", 0x48),
+	       .platform_data = &my_mt9v034_platform_data,
+};
+#endif
+
 /*------------------------------------------------------------------------------
  * Matrix device
  */
@@ -144,7 +170,7 @@ static struct i2c_board_info __initdata ds1307_i2c_bdi = {
 };
 #endif
 
-#if defined(CONFIG_SENSORS_PCF8591_MODULE)
+#if 0 //defined(CONFIG_SENSORS_PCF8591_MODULE)
 #define PCF8591_I2C_BUS (0)
 static struct i2c_board_info __initdata pcf8591_i2c_bdi = {
         I2C_BOARD_INFO("pcf8591", 0x48),
@@ -496,6 +522,15 @@ static void __init sunxi_dev_init(void)
 	printk("ina219 device registered\n");
 #endif
 
+//ankt
+#if 1
+#if defined(APTINA_SENSOR_I2C_ENABLE)
+        printk("###############plat: add aptina sensor device#############\n");
+        i2c_register_board_info(APTINA_SENSOR_I2C_BUS, &aptina_sensor_i2c_bdi, 1);
+#endif
+#endif
+
+#if 0	
 #if defined(CONFIG_INPUT_ADXL34X_I2C_MODULE)
 	printk("plat: add adxl34x device\n");
 	i2c_register_board_info(ADXL34X_I2C_BUS, &adxl34x_i2c_bdi, 1);
@@ -514,6 +549,7 @@ static void __init sunxi_dev_init(void)
 #if defined(CONFIG_SENSORS_PCF8591_MODULE)
 	printk("plat: add pcf8591 device\n");
 	i2c_register_board_info(PCF8591_I2C_BUS, &pcf8591_i2c_bdi, 1);
+#endif
 #endif	
 
 #ifdef CONFIG_ANDROID_RAM_CONSOLE
diff --git a/linux-3.4/drivers/i2c/i2c-core.c b/linux-3.4/drivers/i2c/i2c-core.c
index c0d7c9e..6309080 100755
--- a/linux-3.4/drivers/i2c/i2c-core.c
+++ b/linux-3.4/drivers/i2c/i2c-core.c
@@ -509,6 +509,7 @@ i2c_new_device(struct i2c_adapter *adap, struct i2c_board_info const *info)
 	struct i2c_client	*client;
 	int			status;
 
+	printk("i2c_new_device 0 \n");
 	client = kzalloc(sizeof *client, GFP_KERNEL);
 	if (!client)
 		return NULL;
@@ -531,6 +532,7 @@ i2c_new_device(struct i2c_adapter *adap, struct i2c_board_info const *info)
 	if (status) {
 		dev_err(&adap->dev, "Invalid %d-bit I2C address 0x%02hx\n",
 			client->flags & I2C_CLIENT_TEN ? 10 : 7, client->addr);
+		printk("i2c_new_device 1 \n");
 		goto out_err_silent;
 	}
 
@@ -539,6 +541,7 @@ i2c_new_device(struct i2c_adapter *adap, struct i2c_board_info const *info)
 	if (status)
 		goto out_err;
 
+	printk("i2c_new_device 2 \n");
 	client->dev.parent = &client->adapter->dev;
 	client->dev.bus = &i2c_bus_type;
 	client->dev.type = &i2c_client_type;
@@ -552,6 +555,7 @@ i2c_new_device(struct i2c_adapter *adap, struct i2c_board_info const *info)
 	if (status)
 		goto out_err;
 
+	printk("i2c_new_device 3 \n");
 	dev_dbg(&adap->dev, "client [%s] registered with bus id %s\n",
 		client->name, dev_name(&client->dev));
 
@@ -560,7 +564,9 @@ i2c_new_device(struct i2c_adapter *adap, struct i2c_board_info const *info)
 out_err:
 	dev_err(&adap->dev, "Failed to register i2c client %s at 0x%02x "
 		"(%d)\n", client->name, client->addr, status);
+	printk("i2c_new_device 4 \n");
 out_err_silent:
+	printk("i2c_new_device 5 \n");
 	kfree(client);
 	return NULL;
 }
@@ -1605,6 +1611,7 @@ i2c_new_probed_device(struct i2c_adapter *adap,
 
 	if (addr_list[i] == I2C_CLIENT_END) {
 		dev_dbg(&adap->dev, "Probing failed, no device found\n");
+		printk("i2c_new_probed_device: Probing failed, no device found\n");
 		return NULL;
 	}
 
diff --git a/linux-3.4/drivers/media/video/mt9v032.c b/linux-3.4/drivers/media/video/mt9v032.c
index 75e253a..bff0804 100644
--- a/linux-3.4/drivers/media/video/mt9v032.c
+++ b/linux-3.4/drivers/media/video/mt9v032.c
@@ -12,6 +12,9 @@
  * published by the Free Software Foundation.
  */
 
+//ankt
+#include <linux/clk.h>
+
 #include <linux/delay.h>
 #include <linux/i2c.h>
 #include <linux/log2.h>
@@ -26,12 +29,24 @@
 #include <media/v4l2-device.h>
 #include <media/v4l2-subdev.h>
 
+#include <linux/proc_fs.h>	/* Necessary because we use the proc fs */
+#include <asm/uaccess.h>	/* for copy_from_user */
+
+#include <linux/pinctrl/consumer.h>
+#include <linux/pinctrl/pinconf-sunxi.h>
+
+#include "sunxi-vfe/csi_cci/cci_helper.h"
+
+#include "sunxi-vfe/device/camera_cfg.h"
+#include "sunxi-vfe/vfe_subdev.h"
+
 #define MT9V032_PIXEL_ARRAY_HEIGHT			492
 #define MT9V032_PIXEL_ARRAY_WIDTH			782
 
 #define MT9V032_CHIP_VERSION				0x00
 #define		MT9V032_CHIP_ID_REV1			0x1311
 #define		MT9V032_CHIP_ID_REV3			0x1313
+#define		MT9V034_CHIP_ID_REV1			0x1324
 #define MT9V032_COLUMN_START				0x01
 #define		MT9V032_COLUMN_START_MIN		1
 #define		MT9V032_COLUMN_START_DEF		1
@@ -50,10 +65,13 @@
 #define		MT9V032_WINDOW_WIDTH_MAX		752
 #define MT9V032_HORIZONTAL_BLANKING			0x05
 #define		MT9V032_HORIZONTAL_BLANKING_MIN		43
+#define		MT9V034_HORIZONTAL_BLANKING_MIN		61
 #define		MT9V032_HORIZONTAL_BLANKING_MAX		1023
 #define MT9V032_VERTICAL_BLANKING			0x06
 #define		MT9V032_VERTICAL_BLANKING_MIN		4
+#define		MT9V034_VERTICAL_BLANKING_MIN		2
 #define		MT9V032_VERTICAL_BLANKING_MAX		3000
+#define		MT9V034_VERTICAL_BLANKING_MAX		32288
 #define MT9V032_CHIP_CONTROL				0x07
 #define		MT9V032_CHIP_CONTROL_MASTER_MODE	(1 << 3)
 #define		MT9V032_CHIP_CONTROL_DOUT_ENABLE	(1 << 7)
@@ -63,8 +81,10 @@
 #define MT9V032_SHUTTER_WIDTH_CONTROL			0x0a
 #define MT9V032_TOTAL_SHUTTER_WIDTH			0x0b
 #define		MT9V032_TOTAL_SHUTTER_WIDTH_MIN		1
+#define		MT9V034_TOTAL_SHUTTER_WIDTH_MIN		0
 #define		MT9V032_TOTAL_SHUTTER_WIDTH_DEF		480
 #define		MT9V032_TOTAL_SHUTTER_WIDTH_MAX		32767
+#define		MT9V034_TOTAL_SHUTTER_WIDTH_MAX		32765
 #define MT9V032_RESET					0x0c
 #define MT9V032_READ_MODE				0x0d
 #define		MT9V032_READ_MODE_ROW_BIN_MASK		(3 << 0)
@@ -76,6 +96,8 @@
 #define		MT9V032_READ_MODE_DARK_COLUMNS		(1 << 6)
 #define		MT9V032_READ_MODE_DARK_ROWS		(1 << 7)
 #define MT9V032_PIXEL_OPERATION_MODE			0x0f
+#define		MT9V034_PIXEL_OPERATION_MODE_HDR	(1 << 0)
+#define		MT9V034_PIXEL_OPERATION_MODE_COLOR	(1 << 1)
 #define		MT9V032_PIXEL_OPERATION_MODE_COLOR	(1 << 2)
 #define		MT9V032_PIXEL_OPERATION_MODE_HDR	(1 << 6)
 #define MT9V032_ANALOG_GAIN				0x35
@@ -91,9 +113,12 @@
 #define		MT9V032_DARK_AVG_HIGH_THRESH_MASK	(255 << 8)
 #define		MT9V032_DARK_AVG_HIGH_THRESH_SHIFT	8
 #define MT9V032_ROW_NOISE_CORR_CONTROL			0x70
+#define		MT9V034_ROW_NOISE_CORR_ENABLE		(1 << 0)
+#define		MT9V034_ROW_NOISE_CORR_USE_BLK_AVG	(1 << 1)
 #define		MT9V032_ROW_NOISE_CORR_ENABLE		(1 << 5)
 #define		MT9V032_ROW_NOISE_CORR_USE_BLK_AVG	(1 << 7)
 #define MT9V032_PIXEL_CLOCK				0x74
+#define MT9V034_PIXEL_CLOCK				0x72
 #define		MT9V032_PIXEL_CLOCK_INV_LINE		(1 << 0)
 #define		MT9V032_PIXEL_CLOCK_INV_FRAME		(1 << 1)
 #define		MT9V032_PIXEL_CLOCK_XOR_LINE		(1 << 2)
@@ -113,8 +138,21 @@
 #define MT9V032_AEC_AGC_ENABLE				0xaf
 #define		MT9V032_AEC_ENABLE			(1 << 0)
 #define		MT9V032_AGC_ENABLE			(1 << 1)
+#define MT9V034_AEC_MAX_SHUTTER_WIDTH			0xad
+#define MT9V032_AEC_MAX_SHUTTER_WIDTH			0xbd
 #define MT9V032_THERMAL_INFO				0xc1
 
+#define VREF_POL          V4L2_MBUS_VSYNC_ACTIVE_HIGH
+#define HREF_POL          V4L2_MBUS_HSYNC_ACTIVE_HIGH
+#define CLK_POL           V4L2_MBUS_PCLK_SAMPLE_RISING
+
+//struct vfe_dev *my_dev;
+//struct pinctrl *my_pctrl;
+//struct pinctrl *my_pctrl_0;
+
+static int called=0;
+bool asj = 0;
+struct v4l2_subdev *subdev_apt;
 struct mt9v032 {
 	struct v4l2_subdev subdev;
 	struct media_pad pad;
@@ -126,12 +164,129 @@ struct mt9v032 {
 
 	struct mutex power_lock;
 	int power_count;
+	
+	//struct device *dev;
+	//struct pinctrl *pctrl;
+
+	//ankt
+	struct clk *clk;
 
 	struct mt9v032_platform_data *pdata;
 	u16 chip_control;
 	u16 aec_agc;
 };
 
+//PROC=========================
+
+#define PROCFS_MAX_SIZE		1024
+#define PROCFS_NAME 		"asj"
+
+static struct proc_dir_entry *Our_Proc_File;
+static char procfs_buffer[PROCFS_MAX_SIZE];
+static unsigned long procfs_buffer_size = 0;
+
+struct i2c_client *my_client;
+struct i2c_client *my_client_new;
+static int mt9v032_read(struct i2c_client *client, const u8 reg);
+static int mt9v032_write(struct i2c_client *client, const u8 reg, const u16 data);
+int mt9v032_registered(struct v4l2_subdev *subdev1);
+
+
+extern void vfe_muxto_i2c();
+extern void vfe_muxto_csi();
+
+short val = 0x0000;
+int procfile_read(char *buffer, char **buffer_location, off_t offset, int buffer_length, int *eof, void *data)
+{
+	int ret ;
+	//int func = 3;
+	//long unsigned int config_set;
+	//char * dev_name = "mt9v032";
+	//char * port_name_c = "PE12";
+	//char * port_name_d = "PE13";
+	//char *name = "twi2";
+	//struct pinctrl *my_p = NULL;
+	//devm_pinctrl_put(&client->adapter->dev.parent->pinctrl);
+	//printk("\r\nmt9v032 dev name: %s\r\n",my_client->adapter->dev.kobj.name);
+	//dev_set_name(&my_client->adapter->dev, "twi2");
+	//printk("\r\nmt9v032 dev name: %s\r\n",my_client->adapter->dev.kobj.name);
+
+	//my_p = devm_pinctrl_get_select(&my_client->adapter->dev, "default");
+	//if (IS_ERR_OR_NULL(my_p)) {
+	//	printk("mt9v032 request pinctrl handle for devicefailed!\n");
+	//}
+	//
+	//
+      	//config_set = SUNXI_PINCFG_PACK(SUNXI_PINCFG_TYPE_FUNC,func);
+        //pin_config_set(dev_name,port_name_c,config_set);
+        //pin_config_set(dev_name,port_name_d,config_set);
+
+	//devm_pinctrl_put(my_pctrl_0);
+	//dev_set_name(&my_dev->pdev->dev,"twi2");
+	//dev_set_name(&dev->pdev->dev,"csi%d",dev->id);
+	//my_pctrl = devm_pinctrl_get_select(&my_dev->pdev->dev, "default");
+	//if (IS_ERR_OR_NULL(twi_pctrl)) {
+	//	printk("mt9v032 vip%d request pinctrl for device [%s] failed!\n", dev->id, dev_name(&my_dev->pdev->dev));
+		//return -EINVAL;
+	//}
+
+	s32 data1 = mt9v032_read(my_client, MT9V032_CHIP_VERSION);
+	data1 = mt9v032_read(my_client, MT9V032_PIXEL_OPERATION_MODE);
+	//if(val == 0x0)
+	//	val = 0x0100;
+	//else
+	//	val = 0;
+	ret = mt9v032_write(my_client, MT9V032_PIXEL_OPERATION_MODE, 0);
+	data1 = mt9v032_read(my_client, MT9V032_PIXEL_OPERATION_MODE);
+
+	/*data1 = mt9v032_read(my_client, 0x47);
+	data1 = mt9v032_read(my_client, 0x48);
+	ret = mt9v032_write(my_client, 0x48, 0x007f);
+	ret = mt9v032_write(my_client, 0x47, 0x0081);
+	data1 = mt9v032_read(my_client, 0x47);
+	data1 = mt9v032_read(my_client, 0x48);
+*/
+
+	//vfe_muxto_i2c();
+	//mt9v032_registered(NULL);
+	//devm_pinctrl_put(my_pctrl);
+	//dev_set_name(&dev->pdev->dev,"csi%d",dev->id);
+	//my_dev->pctrl = devm_pinctrl_get_select(&dev->pdev->dev, "default");
+	//if (IS_ERR_OR_NULL(twi_pctrl)) {
+	//	printk("mt9v032 vip%d request pinctrl for device [%s] failed!\n", dev->id, dev_name(&my_dev->pdev->dev));
+		//return -EINVAL;
+	//}
+
+	return ret;
+}
+
+int procfile_write(struct file *file, const char *buffer, unsigned long count, void *data)
+{
+	if ( copy_from_user(procfs_buffer, buffer, procfs_buffer_size) ) {
+		return -EFAULT;
+	}
+
+	return procfs_buffer_size;
+}
+
+
+
+//PROC=========================
+static struct cci_driver cci_drv = {
+	        .name = "mt9v032",//SENSOR_NAME,
+	        .addr_width = 16,//CCI_BITS_16,
+	        .data_width = 8,//CCI_BITS_8,
+};
+
+static void cci_device_release(struct device *dev)
+{
+	        return;
+}
+struct device my_cci_device_def =
+{
+	        .release = cci_device_release,
+};
+
 static struct mt9v032 *to_mt9v032(struct v4l2_subdev *sd)
 {
 	return container_of(sd, struct mt9v032, subdev);
@@ -139,18 +294,38 @@ static struct mt9v032 *to_mt9v032(struct v4l2_subdev *sd)
 
 static int mt9v032_read(struct i2c_client *client, const u8 reg)
 {
+
+	//if(!called) {
+	//	called = 1;
+	//	vfe_muxto_i2c();
+	//}
 	s32 data = i2c_smbus_read_word_swapped(client, reg);
+	//vfe_muxto_csi();
 	dev_dbg(&client->dev, "%s: read 0x%04x from 0x%02x\n", __func__,
 		data, reg);
+	printk("%s: read 0x%04x from 0x%02x\n", __func__,
+		data, reg);
 	return data;
 }
 
 static int mt9v032_write(struct i2c_client *client, const u8 reg,
 			 const u16 data)
 {
+	int ret;
+
+	//if(!called) {
+	//	called = 1;
+		//vfe_muxto_i2c();
+	//}
 	dev_dbg(&client->dev, "%s: writing 0x%04x to 0x%02x\n", __func__,
 		data, reg);
-	return i2c_smbus_write_word_swapped(client, reg, data);
+	printk("%s: writing 0x%04x to 0x%02x\n", __func__,
+		data, reg);
+	//return i2c_smbus_write_word_swapped(client, reg, data);
+	//vfe_muxto_i2c();
+	ret = i2c_smbus_write_word_swapped(client, reg, data);
+	//vfe_muxto_csi();
+	return ret;
 }
 
 static int mt9v032_set_chip_control(struct mt9v032 *mt9v032, u16 clear, u16 set)
@@ -158,10 +333,11 @@ static int mt9v032_set_chip_control(struct mt9v032 *mt9v032, u16 clear, u16 set)
 	struct i2c_client *client = v4l2_get_subdevdata(&mt9v032->subdev);
 	u16 value = (mt9v032->chip_control & ~clear) | set;
 	int ret;
-
+#if 1
 	ret = mt9v032_write(client, MT9V032_CHIP_CONTROL, value);
 	if (ret < 0)
 		return ret;
+#endif
 
 	mt9v032->chip_control = value;
 	return 0;
@@ -187,16 +363,31 @@ mt9v032_update_aec_agc(struct mt9v032 *mt9v032, u16 which, int enable)
 	return 0;
 }
 
+bool on_done = 0;
 static int mt9v032_power_on(struct mt9v032 *mt9v032)
 {
 	struct i2c_client *client = v4l2_get_subdevdata(&mt9v032->subdev);
 	int ret;
 
-	if (mt9v032->pdata->set_clock) {
-		mt9v032->pdata->set_clock(&mt9v032->subdev, 25000000);
-		udelay(1);
-	}
-
+	//ankt
+	//if (mt9v032->pdata->set_clock) {
+	//	mt9v032->pdata->set_clock(&mt9v032->subdev, 25000000);
+	//	udelay(1);
+	//}
+	if(on_done == 1)
+		return 0;
+	
+	//clk_set_rate(mt9v032->clk, 26600000);
+	clk_prepare_enable(mt9v032->clk);
+	udelay(1);
+
+	//while(1) {
+	s32 data = mt9v032_read(client, MT9V032_CHIP_VERSION);
+	
+	//if(data == 1324)
+	//	break;
+	//msleep(100);
+	//}
 	/* Reset the chip and stop data read out */
 	ret = mt9v032_write(client, MT9V032_RESET, 1);
 	if (ret < 0)
@@ -206,19 +397,30 @@ static int mt9v032_power_on(struct mt9v032 *mt9v032)
 	if (ret < 0)
 		return ret;
 
+	on_done = 1;
 	return mt9v032_write(client, MT9V032_CHIP_CONTROL, 0);
 }
 
 static void mt9v032_power_off(struct mt9v032 *mt9v032)
 {
-	if (mt9v032->pdata->set_clock)
-		mt9v032->pdata->set_clock(&mt9v032->subdev, 0);
+	//ankt
+	//if (mt9v032->pdata->set_clock)
+	//	mt9v032->pdata->set_clock(&mt9v032->subdev, 0);
+	printk("mt9v disabling clk, poweroff\n");
+	clk_disable_unprepare(mt9v032->clk);
 }
 
 static int __mt9v032_set_power(struct mt9v032 *mt9v032, bool on)
 {
 	struct i2c_client *client = v4l2_get_subdevdata(&mt9v032->subdev);
 	int ret;
+	
+	//ankt
+	mt9v032->clk = devm_clk_get(&client->dev, NULL);
+	if (IS_ERR(mt9v032->clk))
+		return PTR_ERR(mt9v032->clk);
+	printk("\r\nset_power--good\r\n");
+	//
 
 	if (!on) {
 		mt9v032_power_off(mt9v032);
@@ -290,6 +492,8 @@ static int mt9v032_s_stream(struct v4l2_subdev *subdev, int enable)
 	unsigned int vratio;
 	int ret;
 
+	printk("mt9v Stream on\n");
+
 	if (!enable)
 		return mt9v032_set_chip_control(mt9v032, mode, 0);
 
@@ -464,6 +668,11 @@ static int mt9v032_set_crop(struct v4l2_subdev *subdev,
 
 #define V4L2_CID_TEST_PATTERN		(V4L2_CID_USER_BASE | 0x1001)
 
+static int mt9v032_s_ctrl(struct v4l2_ctrl *ctrl);
+static int _mt9v032_s_ctrl(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
+{
+	return mt9v032_s_ctrl(ctrl);
+}
 static int mt9v032_s_ctrl(struct v4l2_ctrl *ctrl)
 {
 	struct mt9v032 *mt9v032 =
@@ -513,6 +722,8 @@ static int mt9v032_s_ctrl(struct v4l2_ctrl *ctrl)
 		}
 
 		return mt9v032_write(client, MT9V032_TEST_PATTERN, data);
+	default:
+		break;
 	}
 
 	return 0;
@@ -544,6 +755,15 @@ static int mt9v032_set_power(struct v4l2_subdev *subdev, int on)
 {
 	struct mt9v032 *mt9v032 = to_mt9v032(subdev);
 	int ret = 0;
+	
+	printk("mt9v032_set_power %d\n", on);
+
+	if(on == CSI_SUBDEV_PWR_ON)
+		on = 1;
+	else if(CSI_SUBDEV_PWR_OFF)
+		on = 0;
+	else if ( (on!=0) && (on!=1) )
+		return 0;
 
 	mutex_lock(&mt9v032->power_lock);
 
@@ -551,14 +771,15 @@ static int mt9v032_set_power(struct v4l2_subdev *subdev, int on)
 	 * update the power state.
 	 */
 	if (mt9v032->power_count == !on) {
+		//ret = __mt9v032_set_power(mt9v032, 1);
 		ret = __mt9v032_set_power(mt9v032, !!on);
 		if (ret < 0)
 			goto done;
 	}
 
 	/* Update the power count. */
-	mt9v032->power_count += on ? 1 : -1;
-	WARN_ON(mt9v032->power_count < 0);
+	//mt9v032->power_count += on ? 1 : -1;
+	//WARN_ON(mt9v032->power_count < 0);
 
 done:
 	mutex_unlock(&mt9v032->power_lock);
@@ -569,15 +790,49 @@ done:
  * V4L2 subdev internal operations
  */
 
-static int mt9v032_registered(struct v4l2_subdev *subdev)
+#if 0
+static const s64 mt9v034_link_freqs[] = {
+	        13000000,
+		        26600000,
+			        27000000,
+				        0,
+};
+static struct mt9v032_platform_data my_mt9v034_platform_data = {
+	        .clk_pol        = 0,
+		        .link_freqs     = mt9v034_link_freqs,
+			        .link_def_freq  = 26600000,
+};
+#endif
+//struct i2c_client *my_client;
+//struct mt9v032 *my_mt9v032;
+int mt9v032_registered(struct v4l2_subdev *subdev)
 {
+	//struct v4l2_subdev *subdev = subdev_apt;
 	struct i2c_client *client = v4l2_get_subdevdata(subdev);
 	struct mt9v032 *mt9v032 = to_mt9v032(subdev);
 	s32 data;
 	int ret;
 
+	//if(asj==1) {
+	//	subdev = subdev_apt;
+	//	printk("\r\nmt9v032 good\r\n");
+	//}
+	//else {
+	//	subdev = subdev1;
+	//	printk("\r\nmt9v032 bad\r\n");
+	//}
+	//client = my_client;
+	//if(client->addr == 0x24) {
+	//	client->addr = 0x48;
+	//	client->dev.platform_data = &my_mt9v034_platform_data;
+	//}
+
 	dev_info(&client->dev, "Probing MT9V032 at address 0x%02x\n",
 			client->addr);
+	
+	//ret =__mt9v032_set_power(mt9v032, 1);
+	//if (ret < 0)
+	//	printk("\r\nmt9v032_probe 7\r\n");
 
 	ret = mt9v032_power_on(mt9v032);
 	if (ret < 0) {
@@ -587,13 +842,14 @@ static int mt9v032_registered(struct v4l2_subdev *subdev)
 
 	/* Read and check the sensor version */
 	data = mt9v032_read(client, MT9V032_CHIP_VERSION);
-	if (data != MT9V032_CHIP_ID_REV1 && data != MT9V032_CHIP_ID_REV3) {
+	if (data != MT9V032_CHIP_ID_REV1 && data != MT9V032_CHIP_ID_REV3 && 
+			data != MT9V034_CHIP_ID_REV1) {
 		dev_err(&client->dev, "MT9V032 not detected, wrong version "
 				"0x%04x\n", data);
 		return -ENODEV;
 	}
 
-	mt9v032_power_off(mt9v032);
+	//mt9v032_power_off(mt9v032);
 
 	dev_info(&client->dev, "MT9V032 detected at address 0x%02x\n",
 			client->addr);
@@ -606,6 +862,7 @@ static int mt9v032_open(struct v4l2_subdev *subdev, struct v4l2_subdev_fh *fh)
 	struct v4l2_mbus_framefmt *format;
 	struct v4l2_rect *crop;
 
+	printk("mt9v opened\n");
 	crop = v4l2_subdev_get_try_crop(fh, 0);
 	crop->left = MT9V032_COLUMN_START_DEF;
 	crop->top = MT9V032_ROW_START_DEF;
@@ -624,15 +881,171 @@ static int mt9v032_open(struct v4l2_subdev *subdev, struct v4l2_subdev_fh *fh)
 
 static int mt9v032_close(struct v4l2_subdev *subdev, struct v4l2_subdev_fh *fh)
 {
+	printk("mt9 closed\n");
 	return mt9v032_set_power(subdev, 0);
 }
 
+static int mt9v032_init(struct v4l2_subdev *sd, u32 val)
+{
+	printk("mt9v init called\n");
+	const u16 mode = MT9V032_CHIP_CONTROL_MASTER_MODE
+		       | MT9V032_CHIP_CONTROL_DOUT_ENABLE
+		       | MT9V032_CHIP_CONTROL_SEQUENTIAL;
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct mt9v032 *mt9v032 = to_mt9v032(sd);
+
+	return mt9v032_set_chip_control(mt9v032,0, mode);
+}
+
+static int mt9v032_g_chip_ident(struct v4l2_subdev *sd,
+		    struct v4l2_dbg_chip_ident *chip)
+{
+	  struct i2c_client *client = v4l2_get_subdevdata(sd);
+
+	    return v4l2_chip_ident_i2c_client(client, chip, 0x1324, 0);
+}
+
+
+static int sensor_g_exif(struct v4l2_subdev *sd, struct sensor_exif_attribute *exif)
+{
+	int ret = 0;//, gain_val, exp_val;
+	
+	exif->fnumber = 220;
+	exif->focal_length = 180;
+	exif->brightness = 125;
+	exif->flash_fire = 0;
+	exif->iso_speed = 200;
+	exif->exposure_time_num = 1;
+	exif->exposure_time_den = 15;
+	return ret;
+}
+
+static long mt9v032_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
+{
+	int ret=0;
+	switch(cmd) {
+		case GET_SENSOR_EXIF:
+			sensor_g_exif(sd, (struct sensor_exif_attribute *)arg);
+			break;
+		default:
+			return -EINVAL;
+	}
+	printk("mt9v032_ioctl !!\n");
+	return ret;
+}
+static int mt9v032_g_mbus_config(struct v4l2_subdev *sd,
+           struct v4l2_mbus_config *cfg)
+{
+  cfg->type = V4L2_MBUS_PARALLEL;
+  cfg->flags = V4L2_MBUS_MASTER | VREF_POL | HREF_POL | CLK_POL ;
+  
+  return 0;
+}
+static int mt9v032_s_parm(struct v4l2_subdev *sd, struct v4l2_streamparm *parms)
+{
+  struct v4l2_captureparm *cp = &parms->parm.capture;
+  struct v4l2_fract *tpf = &cp->timeperframe;
+  //struct sensor_info *info = to_state(sd);
+  unsigned char div;
+  
+  printk("sensor_s_parm\n");
+  
+  if (parms->type != V4L2_BUF_TYPE_VIDEO_CAPTURE){
+  	printk("parms->type!=V4L2_BUF_TYPE_VIDEO_CAPTURE\n");
+    return -EINVAL;
+  }
+  
+  if (tpf->numerator == 0 || tpf->denominator == 0) {
+    tpf->numerator = 1;
+    tpf->denominator = 60;//30;/* Reset to full rate */
+    printk("sensor frame rate reset to full rate!\n");
+  }
+  
+  div = 60/(tpf->denominator/tpf->numerator);
+  //div = 30/(tpf->denominator/tpf->numerator);
+  if(div > 15 || div == 0)
+  {
+  	printk("SENSOR_FRAME_RATE=%d\n",60);//30);
+  	printk("tpf->denominator=%d\n",tpf->denominator);
+  	printk("tpf->numerator=%d\n",tpf->numerator);
+    return -EINVAL;
+  }
+  
+  printk("set frame rate %d\n",tpf->denominator/tpf->numerator);
+  
+	return 0;
+}
+
+static int mt9v032_g_parm(struct v4l2_subdev *sd, struct v4l2_streamparm *parms)
+{
+	struct v4l2_captureparm *cp = &parms->parm.capture;
+	//struct sensor_info *info = to_state(sd);
+
+	if (parms->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
+		return -EINVAL;
+	
+	memset(cp, 0, sizeof(struct v4l2_captureparm));
+	cp->capability = V4L2_CAP_TIMEPERFRAME;
+	cp->capturemode = V4L2_MODE_VIDEO;
+	
+	cp->timeperframe.numerator = 1;//info->tpf.numerator;
+	cp->timeperframe.denominator = 60;//30;//info->tpf.denominator;
+	 
+	return 0;
+}
+
+static int mt9v032_s_fmt(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *fmt) 
+{
+	return 0;
+}
+static int mt9v032_enum_size(struct v4l2_subdev *sd, struct v4l2_frmsizeenum *fsize)
+{
+  //if(fsize->index > N_WIN_SIZES-1)
+  //	return -EINVAL;
+  
+  fsize->type = V4L2_FRMSIZE_TYPE_DISCRETE;
+  fsize->discrete.width = 768;//sensor_win_sizes[fsize->index].width;
+  fsize->discrete.height = 480;//sensor_win_sizes[fsize->index].height;
+  printk("%s %d width=%d height=%d\n", __func__, fsize->index,  fsize->discrete.width,  fsize->discrete.height);
+  return 0;
+}
+static int mt9v032_enum_fmt(struct v4l2_subdev *sd, unsigned index,
+                 enum v4l2_mbus_pixelcode *code)
+{
+  //if (index >= N_FMTS)
+  //  return -EINVAL;
+
+  printk("%s %d %x\n", __func__, index, *code);
+  *code = V4L2_MBUS_FMT_SGRBG10_1X10;//sensor_formats[index].mbus_code;
+  return 0;
+}
+static int mt9v032_try_fmt(struct v4l2_subdev *sd,
+		             struct v4l2_mbus_framefmt *fmt)
+{
+
+  fmt->width = 768;//wsize->width;
+  fmt->height = 480;//wsize->height;
+  return 0;
+}
+
+
 static struct v4l2_subdev_core_ops mt9v032_subdev_core_ops = {
+	.g_chip_ident = mt9v032_g_chip_ident,
+  	.s_ctrl	 	= _mt9v032_s_ctrl,
 	.s_power	= mt9v032_set_power,
+	.init		= mt9v032_init,
+  	.ioctl 		= mt9v032_ioctl,
 };
 
 static struct v4l2_subdev_video_ops mt9v032_subdev_video_ops = {
 	.s_stream	= mt9v032_s_stream,
+  	.try_mbus_fmt = mt9v032_try_fmt,
+  	.enum_mbus_fmt = mt9v032_enum_fmt,
+  	.enum_framesizes = mt9v032_enum_size,
+  	.s_mbus_fmt 	= mt9v032_s_fmt,
+  	.s_parm 	= mt9v032_s_parm,
+  	.g_parm 	= mt9v032_g_parm,
+  	.g_mbus_config 	= mt9v032_g_mbus_config,
 };
 
 static struct v4l2_subdev_pad_ops mt9v032_subdev_pad_ops = {
@@ -656,6 +1069,40 @@ static const struct v4l2_subdev_internal_ops mt9v032_subdev_internal_ops = {
 	.close = mt9v032_close,
 };
 
+#if 0
+static struct device_attribute cci_device_attrs[] = {
+	__ATTR(addr_width,  S_IWUSR | S_IRUGO, cci_device_addr_width_show, cci_device_addr_width_store),
+	__ATTR(data_width,  S_IWUSR | S_IRUGO, cci_device_data_width_show, cci_device_data_width_store),
+	__ATTR(read_value, S_IRUGO, cci_device_read_value_show, NULL),
+	__ATTR(read_flag,  S_IWUSR | S_IRUGO, cci_device_read_flag_show, cci_device_read_flag_store),
+	__ATTR(cci_client,  S_IWUSR | S_IRUGO, cci_sys_show, cci_sys_store),
+};
+#endif
+
+
+static int cci_sys_register(struct cci_driver *drv_data)
+{
+	int i, ret;
+	drv_data->cci_device = my_cci_device_def;
+	dev_set_name(&drv_data->cci_device, drv_data->name);
+	
+	if (device_register(&drv_data->cci_device))
+		printk("error device_register()\n");
+	
+	dev_set_drvdata(&drv_data->cci_device,drv_data);
+#if 0
+	/* sysfs entries */
+	for (i = 0; i < ARRAY_SIZE(cci_device_attrs); i++) {
+		ret = device_create_file(&drv_data->cci_device, &cci_device_attrs[i]);
+		if (ret) {
+			printk("device_create_file error\n");
+			device_remove_file(&drv_data->cci_device, &drv_data->dev_attr_cci);
+		}
+	}
+#endif
+	return 0;
+}
+
 /* -----------------------------------------------------------------------------
  * Driver initialization and probing
  */
@@ -667,6 +1114,18 @@ static int mt9v032_probe(struct i2c_client *client,
 	unsigned int i;
 	int ret;
 
+	//ankt
+	printk("\r\nmt9v032_probe 0\r\n");
+	//if(asj ==1) {
+	//	client = my_client;
+	//	return 0;
+	//}
+
+	//if(client->addr == 0x24) {
+	//	client->addr = 0x48;
+	//	client->dev.platform_data = &my_mt9v034_platform_data;
+	//}
+
 	if (!i2c_check_functionality(client->adapter,
 				     I2C_FUNC_SMBUS_WORD_DATA)) {
 		dev_warn(&client->adapter->dev,
@@ -674,12 +1133,18 @@ static int mt9v032_probe(struct i2c_client *client,
 		return -EIO;
 	}
 
+	printk("\r\nmt9v032_probe 1\r\n");
 	mt9v032 = kzalloc(sizeof(*mt9v032), GFP_KERNEL);
 	if (!mt9v032)
 		return -ENOMEM;
 
+	mt9v032->clk = devm_clk_get(&client->dev, "csi_m");
+	if (IS_ERR(mt9v032->clk))
+		return PTR_ERR(mt9v032->clk);
+
 	mutex_init(&mt9v032->power_lock);
 	mt9v032->pdata = client->dev.platform_data;
+	printk("\r\nmt9v032_probe 2\r\n");
 
 	v4l2_ctrl_handler_init(&mt9v032->ctrls, ARRAY_SIZE(mt9v032_ctrls) + 4);
 
@@ -695,6 +1160,7 @@ static int mt9v032_probe(struct i2c_client *client,
 			  V4L2_CID_EXPOSURE, MT9V032_TOTAL_SHUTTER_WIDTH_MIN,
 			  MT9V032_TOTAL_SHUTTER_WIDTH_MAX, 1,
 			  MT9V032_TOTAL_SHUTTER_WIDTH_DEF);
+	printk("\r\nmt9v032_probe 3\r\n");
 
 	for (i = 0; i < ARRAY_SIZE(mt9v032_ctrls); ++i)
 		v4l2_ctrl_new_custom(&mt9v032->ctrls, &mt9v032_ctrls[i], NULL);
@@ -705,6 +1171,7 @@ static int mt9v032_probe(struct i2c_client *client,
 		printk(KERN_INFO "%s: control initialization error %d\n",
 		       __func__, mt9v032->ctrls.error);
 
+	printk("\r\nmt9v032_probe 4\r\n");
 	mt9v032->crop.left = MT9V032_COLUMN_START_DEF;
 	mt9v032->crop.top = MT9V032_ROW_START_DEF;
 	mt9v032->crop.width = MT9V032_WINDOW_WIDTH_DEF;
@@ -718,14 +1185,89 @@ static int mt9v032_probe(struct i2c_client *client,
 
 	mt9v032->aec_agc = MT9V032_AEC_ENABLE | MT9V032_AGC_ENABLE;
 
+	ret = 0;
+#if 1
 	v4l2_i2c_subdev_init(&mt9v032->subdev, client, &mt9v032_subdev_ops);
 	mt9v032->subdev.internal_ops = &mt9v032_subdev_internal_ops;
 	mt9v032->subdev.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
+	printk("\r\nmt9v032_probe 5\r\n");
 
 	mt9v032->pad.flags = MEDIA_PAD_FL_SOURCE;
 	ret = media_entity_init(&mt9v032->subdev.entity, 1, &mt9v032->pad, 0);
 	if (ret < 0)
+	//ankt
 		kfree(mt9v032);
+#endif
+	//goto err;
+	//mt9v032->subdev.dev = &client->dev;
+	//ret = v4l2_async_register_subdev(&mt9v032->subdev);
+	//if (ret < 0)
+	//	goto err;
+	//return 0;
+//err:
+	//media_entity_cleanup(&mt9v032->subdev.entity);
+	//v4l2_ctrl_handler_free(&mt9v032->ctrls);
+	//kfree(mt9v032);
+	//ankt
+	printk("\r\nmt9v032_probe 6\r\n");
+	//cci_sys_register(&cci_drv);
+	//if(client->addr == 0x48) {
+		my_client = client;
+		//my_client_new = kzalloc(sizeof(*my_client_new), GFP_KERNEL);
+
+		//memcpy(my_client_new, client, sizeof(struct i2c_client));
+		//my_client = my_client_new;
+
+		//my_client_new.flags = client->flags;
+		//my_client_new.addr = client->addr;
+		//strcpy(my_client_new.name, client->name);
+		//my_client_new.adapter = client->adapter;
+
+		//my_client_new.driver = client->driver;
+		//my_client_new.dev = client->dev;
+		//my_client_new.irq = client->irq;
+		//my_client_new.detected = client->detected;
+		//my_client = &my_client_new;
+
+	//	my_mt9v032 = mt9v032;
+	//} else {
+	//	mt9v032 = my_mt9v032;
+	//}
+#if 0
+	subdev_apt = &mt9v032->subdev;
+	mt9v032_registered(&mt9v032->subdev);
+	mt9v032_registered(&mt9v032->subdev);
+	mt9v032_registered(&mt9v032->subdev);
+	mt9v032_registered(&mt9v032->subdev);
+	asj = 1;
+#endif
+	//ret =__mt9v032_set_power(mt9v032, 1);
+	//if (ret < 0)
+	//	printk("\r\nmt9v032_probe 7\r\n");
+	
+	//proc
+	/* create the /proc file */
+	Our_Proc_File = create_proc_entry(PROCFS_NAME, 0644, NULL);
+	
+	if (Our_Proc_File == NULL) {
+		remove_proc_entry(PROCFS_NAME, NULL);
+		printk(KERN_ALERT "mt9v032 Error: Could not initialize /proc/%s\n",
+		PROCFS_NAME);
+		//return -ENOMEM;
+	}
+	
+	Our_Proc_File->read_proc  = procfile_read;
+	Our_Proc_File->write_proc = procfile_write;
+	//Our_Proc_File->owner 	  = THIS_MODULE;
+	Our_Proc_File->mode 	  = S_IFREG | S_IRUGO;
+	Our_Proc_File->uid 	  = 0;
+	Our_Proc_File->gid 	  = 0;
+	Our_Proc_File->size 	  = 37;
+
+	printk(KERN_INFO "mt9v032 /proc/%s created\n", PROCFS_NAME);
+
+
+	//proc
 
 	return ret;
 }
@@ -734,7 +1276,11 @@ static int mt9v032_remove(struct i2c_client *client)
 {
 	struct v4l2_subdev *subdev = i2c_get_clientdata(client);
 	struct mt9v032 *mt9v032 = to_mt9v032(subdev);
-
+	
+	//ankt
+	//v4l2_async_unregister_subdev(subdev);
+	//v4l2_ctrl_handler_free(&mt9v032->ctrls);
+	//ankt
 	v4l2_device_unregister_subdev(subdev);
 	media_entity_cleanup(&subdev->entity);
 	kfree(mt9v032);
diff --git a/linux-3.4/drivers/media/video/sunxi-vfe/Makefile b/linux-3.4/drivers/media/video/sunxi-vfe/Makefile
index 6a4bdea..b3c6066 100755
--- a/linux-3.4/drivers/media/video/sunxi-vfe/Makefile
+++ b/linux-3.4/drivers/media/video/sunxi-vfe/Makefile
@@ -1,4 +1,4 @@
-EXTRA_LDFLAGS += --strip-debug
+#EXTRA_LDFLAGS += --strip-debug
 obj-$(CONFIG_CSI_VFE) += vfe_os.o
 obj-$(CONFIG_CSI_VFE) += vfe_subdev.o
 obj-$(CONFIG_CSI_VFE) += device/
@@ -23,7 +23,7 @@ vfe_v4l2-y					+= isp_cfg/isp_cfg.o
 vfe_v4l2-y					+= utility/cfg_op.o
 vfe_v4l2-y					+= vfe.o
 vfe_v4l2-y					+= lib/libisp
-EXTRA_LDFLAGS += --strip-debug		
+#EXTRA_LDFLAGS += --strip-debug		
 ifneq ($(strip $(CONFIG_ARCH_SUN9I)),)
 vfe_v4l2-y					+= lib/lib_mipicsi2_v2
 else ifneq ($(strip $(CONFIG_ARCH_SUN8IW6)),)
@@ -37,4 +37,4 @@ vfe_v4l2-y					+= mipi_csi/bsp_mipi_csi_v1.o \
 else
 obj-$(CONFIG_CSI_VFE) += vfe_v4l2.o
 vfe_v4l2-y					+= lib/lib_mipicsi2_v1
-endif
\ No newline at end of file
+endif
diff --git a/linux-3.4/drivers/media/video/sunxi-vfe/config.c b/linux-3.4/drivers/media/video/sunxi-vfe/config.c
index fb79ef3..3d966ec 100755
--- a/linux-3.4/drivers/media/video/sunxi-vfe/config.c
+++ b/linux-3.4/drivers/media/video/sunxi-vfe/config.c
@@ -171,6 +171,7 @@ int fetch_sensor_list(struct sensor_config_init *sensor_cfg_ini , char *main, st
 	SensorCommon = &SensorParamCommon[0];
 	//fetch sensor common config;
 	vfe_print("fetch sensor common config! \n");
+	printk("fetch_sensor_list: fetch sensor common config! \n");
 	for (i = 0; i < ARRAY_SIZE(SensorParamCommon);  i++)
 	{
 		if(main == NULL || SensorCommon->sub == NULL)
@@ -389,6 +390,8 @@ int fetch_config(struct vfe_dev *dev)
       type = script_get_item(vfe_para, dev_para, &val);
       if (SCIRPT_ITEM_VALUE_TYPE_INT != type) {
         vfe_err("fetch vip_dev%d_twi_addr from sys_config failed\n", i);
+	dev->ccm_cfg[i]->i2c_addr = 0x90;
+	//ankt
       } else {
         dev->ccm_cfg[i]->i2c_addr = val.val;
       }
@@ -396,7 +399,9 @@ int fetch_config(struct vfe_dev *dev)
       sprintf(dev_para, "vip_dev%d_mname", i);
       type = script_get_item(vfe_para, dev_para, &val);
       if (SCIRPT_ITEM_VALUE_TYPE_STR != type) {
-        char tmp_str[]="ov5650";
+        char tmp_str[]="mt9v032";
+	//ankt
+        //char tmp_str[]="ov5650";
         strcpy(dev->ccm_cfg[i]->ccm,tmp_str);
         vfe_err("fetch vip_dev%d_mname from sys_config failed\n", i);
       } else {
@@ -421,6 +426,9 @@ int fetch_config(struct vfe_dev *dev)
     type = script_get_item(vfe_para, dev_para, &val);
     if (SCIRPT_ITEM_VALUE_TYPE_INT != type) {
       vfe_dbg(0,"fetch vip_dev%d_fmt from sys_config failed\n", i);
+      printk("vfe fetch vip_dev%d_fmt from sys_config failed\n", i);
+      //val.val = 1;
+      //dev->ccm_cfg[i]->is_bayer_raw = val.val;
     } else {
       dev->ccm_cfg[i]->is_bayer_raw = val.val;
     }
@@ -662,8 +670,12 @@ int fetch_config(struct vfe_dev *dev)
 #else
   int type;
 #if defined(CONFIG_ARCH_SUN8IW3P1) || defined(CONFIG_ARCH_SUN9IW1P1)
-	unsigned int i2c_addr_vip0[2] = {0x78,0xff};
-	unsigned char ccm_vip0_dev0[] = {"ov5640",};
+	//unsigned int i2c_addr_vip0[2] = {0x78,0xff};
+	//unsigned char ccm_vip0_dev0[] = {"ov5640",};
+  //ankt
+  unsigned int i2c_addr_vip0[2] = {0x48,0xff};
+  unsigned char ccm_vip0_dev0[] = {"mt9v032",};
+
   unsigned char ccm_vip0_dev1[] = {"",};
 	unsigned int vip0_is_isp_used[2] = {1,1};
   unsigned int vip0_is_bayer_raw[2] = {0,0};
diff --git a/linux-3.4/drivers/media/video/sunxi-vfe/isp_cfg/isp_cfg.c b/linux-3.4/drivers/media/video/sunxi-vfe/isp_cfg/isp_cfg.c
index 5422abe..63b0354 100755
--- a/linux-3.4/drivers/media/video/sunxi-vfe/isp_cfg/isp_cfg.c
+++ b/linux-3.4/drivers/media/video/sunxi-vfe/isp_cfg/isp_cfg.c
@@ -33,6 +33,8 @@ struct isp_cfg_item isp_cfg_array[] =
 	{	"h22_mipi",		    &h22_mipi_isp_cfg,	  },    
 	{	"gc1004_mipi",		&gc1004_mipi_isp_cfg,	},    
 	{	"ov4689",		      &ov4689_isp_cfg,	    },    
+	//ankt
+	{	"mt9v032",		      &ov4689_isp_cfg,	    },    
 };
 
 int get_isp_cfg(char *isp_cfg_name, struct isp_cfg_item *isp_cfg_info)
diff --git a/linux-3.4/drivers/media/video/sunxi-vfe/platform/sun8iw7p1_vfe_cfg.h b/linux-3.4/drivers/media/video/sunxi-vfe/platform/sun8iw7p1_vfe_cfg.h
index bdb6d1f..f84a2e2 100755
--- a/linux-3.4/drivers/media/video/sunxi-vfe/platform/sun8iw7p1_vfe_cfg.h
+++ b/linux-3.4/drivers/media/video/sunxi-vfe/platform/sun8iw7p1_vfe_cfg.h
@@ -23,7 +23,7 @@
 
 #define VFE_ISP_REGULATOR				""
 #define VFE_CSI_REGULATOR				""
-#define USE_SPECIFIC_CCI
+//#define USE_SPECIFIC_CCI
 #define CSI0_CCI_REG_BASE				0x01cb3000
 
 #define CSI0_REGS_BASE          				0x01cb0000
diff --git a/linux-3.4/drivers/media/video/sunxi-vfe/utility/sensor_info.c b/linux-3.4/drivers/media/video/sunxi-vfe/utility/sensor_info.c
index 39c24c5..bc6654f 100755
--- a/linux-3.4/drivers/media/video/sunxi-vfe/utility/sensor_info.c
+++ b/linux-3.4/drivers/media/video/sunxi-vfe/utility/sensor_info.c
@@ -22,7 +22,7 @@ struct sensor_item sensor_list_t[] =
 {
 	//         name                  i2c_addr               sensor type               sensor size          sensor max pclk
 	{	"ov2640"		,	0x60,		SENSOR_YUV	,	 PIXEL_NUM_2M		, CORE_CLK_RATE_FOR_2M},
-	{	"ov5640"		,	0x78,		SENSOR_YUV	,	 PIXEL_NUM_5M		, CORE_CLK_RATE_FOR_5M},
+	//{	"ov5640"		,	0x78,		SENSOR_YUV	,	 PIXEL_NUM_5M		, CORE_CLK_RATE_FOR_5M},
 	{	"ov5647"		,	0x6c,		SENSOR_RAW	,	 PIXEL_NUM_5M		, CORE_CLK_RATE_FOR_5M},
 	{	"ov5647_mipi"	,	0x6c,		SENSOR_RAW	,	 PIXEL_NUM_5M		, CORE_CLK_RATE_FOR_5M},
 	{	"ov5650"		,	0x50,		SENSOR_RAW	,	 PIXEL_NUM_5M		, CORE_CLK_RATE_FOR_5M},
@@ -59,6 +59,9 @@ struct sensor_item sensor_list_t[] =
 	{	"nt99252"		,	0x6c,		SENSOR_YUV	,	 PIXEL_NUM_2M		, CORE_CLK_RATE_FOR_2M},
 	{	"ov7736"		,	0x42,		SENSOR_YUV	,	 PIXEL_NUM_0_3M		, CORE_CLK_RATE_FOR_2M},
 	{	"gc2155"		,	0x78,		SENSOR_YUV	,	 PIXEL_NUM_2M		, CORE_CLK_RATE_FOR_2M},
+//ankt
+	//{       "mt9v032"                ,       0x48,           SENSOR_RAW      ,        PIXEL_NUM_3M           , CORE_CLK_RATE_FOR_3M},
+	{       "mt9v032"                ,       0x48,           SENSOR_YUV      ,        PIXEL_NUM_3M           , CORE_CLK_RATE_FOR_3M},
 
 };
 int get_sensor_info(char *sensor_name, struct sensor_item *sensor_info)
@@ -69,6 +72,8 @@ int get_sensor_info(char *sensor_name, struct sensor_item *sensor_info)
 		if(strcmp(sensor_name,sensor_list_t[i].sensor_name) == 0)
 		{
 			*sensor_info = sensor_list_t[i];
+			//*sensor_info = sensor_list_t[SENSOR_ARRAY_SIZE(sensor_list_t)-1];
+			printk("get_sensor_info %s\n",sensor_list_t[i].sensor_name);
 			return 0;
 		}
 	}
diff --git a/linux-3.4/drivers/media/video/sunxi-vfe/vfe.c b/linux-3.4/drivers/media/video/sunxi-vfe/vfe.c
index 225dac8..ae0b194 100755
--- a/linux-3.4/drivers/media/video/sunxi-vfe/vfe.c
+++ b/linux-3.4/drivers/media/video/sunxi-vfe/vfe.c
@@ -45,6 +45,7 @@
 #include "utility/vfe_io.h"
 #include <linux/ion_sunxi.h>
 
+#include <media/mt9v032.h>
 #define IS_FLAG(x,y) (((x)&(y)) == y)
 #define CLIP_MAX(x,max) ((x) > max ? max : x )
 
@@ -116,6 +117,7 @@ module_param(vfe_i2c_dbg,uint, S_IRUGO|S_IWUSR);
 module_param(isp_log,uint, S_IRUGO|S_IWUSR);
 
 module_param(vips,uint, S_IRUGO|S_IWUSR);
+void vfe_fix_mux();
 static ssize_t vfe_dbg_en_show(struct device *dev,
 		    struct device_attribute *attr, char *buf)
 {
@@ -400,6 +402,10 @@ static struct vfe_fmt formats[] = {
 };
 
 static enum v4l2_mbus_pixelcode try_yuv422_bus[] = {
+	//V4L2_MBUS_FMT_SGRBG10_1X10,
+	//V4L2_MBUS_FMT_SGRBG8_8X1,
+	V4L2_MBUS_FMT_SGRBG8_1X8,
+	//V4L2_MBUS_FMT_YUYV10_2X10,
 	V4L2_MBUS_FMT_UYVY10_20X1,
 	V4L2_MBUS_FMT_UYVY8_16X1,
 
@@ -949,7 +955,7 @@ static inline void vfe_set_addr(struct vfe_dev *dev,struct vfe_buffer *buffer)
 	
 	if(vb_buf == NULL || vb_buf->priv == NULL)
 	{
-		vfe_err("videobuf_buffer->priv is NULL!\n");
+		vfe_err("videobuf_buffer->priv is NULL! vb%d vgp%d\n", vb_buf, vb_buf->priv);
 		return;
 	}
 
@@ -1399,7 +1405,7 @@ static void vfe_isp_stat_parse(struct isp_gen_settings * isp_gen)
 /*
  *  the interrupt routine
  */
-
+int irq_count = 0;
 static irqreturn_t vfe_isr(int irq, void *priv)
 {
 	int i;
@@ -1415,7 +1421,8 @@ static irqreturn_t vfe_isr(int irq, void *priv)
 #endif		
 
 	FUNCTION_LOG;
-	vfe_dbg(0,"vfe interrupt!!!\n");
+	//vfe_dbg(0,"vfe interrupt!!!\n");
+	//printk("vfe interrupt : %d!!!\n",irq_count++);
 	if(vfe_is_generating(dev) == 0)
 	{
 		bsp_csi_int_clear_status(dev->vip_sel, dev->cur_ch,CSI_INT_ALL);
@@ -1503,17 +1510,17 @@ isp_exp_handle:
 			bsp_csi_int_disable(dev->vip_sel, dev->cur_ch,CSI_INT_FRAME_DONE);
 		if (dev->first_flag == 0) {
 			dev->first_flag++;
-			vfe_dbg(0, "capture video mode!\n");
+			//vfe_dbg(0, "capture video mode!\n");
 			goto set_isp_stat_addr;
 		}
 		if (dev->first_flag == 1) {
 			dev->first_flag++;
-			vfe_dbg(0, "capture video first frame done!\n");
+			//vfe_dbg(0, "capture video first frame done!\n");
 		}
 
 		//video buffer handle:
 		if ((&dma_q->active) == dma_q->active.next->next->next) {
-			vfe_dbg(0, "Only two buffer left for csi\n");
+			//vfe_dbg(0, "Only two buffer left for csi\n");
 			dev->first_flag=0;
 			goto unlock;
 		}
@@ -1521,7 +1528,7 @@ isp_exp_handle:
 
 		/* Nobody is waiting on this buffer*/
 		if (!waitqueue_active(&buf->vb.done)) {
-			vfe_dbg(0, " Nobody is waiting on this video buffer,buf = 0x%p\n",buf);
+			//vfe_dbg(0, " Nobody is waiting on this video buffer,buf = 0x%p\n",buf);
 		}
 		list_del(&buf->vb.queue);
 		do_gettimeofday(&buf->vb.ts);
@@ -2061,6 +2068,7 @@ static enum v4l2_mbus_pixelcode *try_fmt_internal(struct vfe_dev *dev,struct v4l
   f->fmt.pix.width = ccm_fmt.width;
   f->fmt.pix.height = ccm_fmt.height;
 
+  vfe_dbg(0,"my pixel code = %x at %s\n",V4L2_MBUS_FMT_SGRBG10_1X10,__func__);
   vfe_dbg(0,"bus pixel code = %x at %s\n",*bus_pix_code,__func__);
   vfe_dbg(0,"pix->width = %d at %s\n",f->fmt.pix.width,__func__);
   vfe_dbg(0,"pix->height = %d at %s\n",f->fmt.pix.height,__func__);
@@ -2611,7 +2619,7 @@ static int vidioc_streamon(struct file *file, void *priv, enum v4l2_buf_type i)
   int ret = 0;
   mutex_lock(&dev->stream_lock);
 //  spin_lock(&dev->slock);//debug
-  vfe_dbg(0,"video stream on\n");
+  printk("video stream on\n");
   if (i != V4L2_BUF_TYPE_VIDEO_CAPTURE) {
     ret = -EINVAL;
     goto streamon_unlock;
@@ -2703,6 +2711,8 @@ static int vidioc_streamon(struct file *file, void *priv, enum v4l2_buf_type i)
 	if(dev->mbus_type == V4L2_MBUS_CSI2)
 		bsp_mipi_csi_protocol_enable(dev->mipi_sel);
 #endif
+	v4l2_subdev_call(dev->sd,video,s_stream,1);
+  	printk("video stream generating\n");
 	vfe_start_generating(dev);
 
 streamon_unlock:
@@ -2777,6 +2787,8 @@ static int vidioc_streamoff(struct file *file, void *priv, enum v4l2_buf_type i)
   if(dev->is_isp_used)
     bsp_isp_disable();
   bsp_csi_disable(dev->vip_sel);
+	printk("video stream generating stream stopped\n");
+	v4l2_subdev_call(dev->sd,video,s_stream,0);
 streamoff_unlock:
   //spin_unlock(&dev->slock);//debug
   mutex_unlock(&dev->stream_lock);
@@ -4010,6 +4022,10 @@ static ssize_t vfe_read(struct file *file, char __user *data, size_t count, loff
 					file->f_flags & O_NONBLOCK);
 	} else {
 		vfe_err("csi is not generating!\n");
+		//vidioc_streamon(file, NULL, V4L2_BUF_TYPE_VIDEO_CAPTURE);
+		//return videobuf_read_stream(&dev->vb_vidq, data, count, ppos, 0,
+		//			file->f_flags & O_NONBLOCK);
+
 		return -EINVAL;
 	}
 }
@@ -4050,6 +4066,7 @@ static int vfe_open(struct file *file)
 	int ret;//,input_num;
 
 	vfe_print("vfe_open\n");
+	printk("vfe_open\n");
 	if (vfe_is_opened(dev)) {
 		vfe_err("device open busy\n");
 		ret = -EBUSY;
@@ -4092,6 +4109,7 @@ static int vfe_open(struct file *file)
 		vfe_opened_num ++;
 		internal_s_input(dev, 0);
 	}
+	printk("vfe opened ok\n");
 	return ret;
 }
 
@@ -4168,10 +4186,10 @@ static int vfe_mmap(struct file *file, struct vm_area_struct *vma)
 {
 	struct vfe_dev *dev = video_drvdata(file);
 	int ret;
-	vfe_dbg(0,"mmap called, vma=0x%08lx\n", (unsigned long)vma);
+	//vfe_dbg(0,"mmap called, vma=0x%08lx\n", (unsigned long)vma);
 	ret = videobuf_mmap_mapper(&dev->vb_vidq, vma);
-	vfe_dbg(0,"vma start=0x%08lx, size=%ld, ret=%d\n", (unsigned long)vma->vm_start,
-			(unsigned long)vma->vm_end - (unsigned long)vma->vm_start, ret);
+	//vfe_dbg(0,"vma start=0x%08lx, size=%ld, ret=%d\n", (unsigned long)vma->vm_start,
+		//	(unsigned long)vma->vm_end - (unsigned long)vma->vm_start, ret);
 	return ret;
 }
 
@@ -4234,15 +4252,100 @@ static struct video_device vfe_template[] =
         },
 };
 
+struct vfe_dev *my_dev;
+struct pinctrl *twi_pctrl;
+//extern struct pinctrl *my_pctrl_0;
+
+void vfe_muxto_i2c()
+{
+
+	struct vfe_dev *dev = my_dev;
+
+	if(dev == NULL)
+		return;
+
+	devm_pinctrl_put(dev->pctrl);
+	dev_set_name(&dev->pdev->dev,"twi2");
+	twi_pctrl = devm_pinctrl_get_select(&dev->pdev->dev, "default");
+	if (IS_ERR_OR_NULL(twi_pctrl)) {
+		vfe_err("my vip%d request pinctrl handle for device [%s] failed!\n", dev->id, dev_name(&dev->pdev->dev));
+		//	return -EINVAL;
+	}
+	dev_set_name(&dev->pdev->dev,"sunxi_vfe.%d",dev->id);
+	msleep(100);
+
+	return ;
+}
+
+void vfe_muxto_csi()
+{
+	struct vfe_dev *dev = my_dev;
+	if(dev == NULL)
+		return;
+
+	devm_pinctrl_put(twi_pctrl);
+	dev_set_name(&dev->pdev->dev,"csi%d",dev->id);
+	dev->pctrl = devm_pinctrl_get_select(&dev->pdev->dev, "default");
+	if (IS_ERR_OR_NULL(dev->pctrl)) {
+		vfe_err("my vip%d request pinctrl handle for device [%s] failed!\n", dev->id, dev_name(&dev->pdev->dev));
+		//	return -EINVAL;
+	}
+	dev_set_name(&dev->pdev->dev,"sunxi_vfe.%d",dev->id);
+	msleep(100);
+
+	return;
+}
+
+void vfe_fix_mux()
+{
+	void __iomem *pe_cfg1_reg;
+	unsigned int addr = 0x01c20894;
+	unsigned int size = 0x4;
+	unsigned int value = 0;
+	unsigned int fix = 0xff33ffff;
+	unsigned int fix1 = 0x0;//0x07000000;
+	//return;
+	
+	if(!request_mem_region(addr, size, "fix_mux_vfe")) {
+		printk("vfe_fix_mux error request_mem_region\n");
+		return;
+	}
+	pe_cfg1_reg = ioremap(addr, size);
+	if(!pe_cfg1_reg) {
+		release_mem_region(addr, size);
+		printk("vfe_fix_mux error request_mem_region\n");
+		return;
+	}
+
+	value = ioread32(pe_cfg1_reg);
+	value &= fix;
+	value |= fix1;
+	iowrite32(value, pe_cfg1_reg);
+
+	iounmap(pe_cfg1_reg);
+	release_mem_region(addr,size);
+	msleep(100);
+	printk("vfe_fix_mux error - good work!!\n");
+
+	return;
+}
+
+
 static int vfe_request_pin(struct vfe_dev *dev, int enable)
 {
 	int ret = 0;
+	//struct pinctrl *twi_pctrl;
 #ifdef VFE_GPIO
 	//to cheat the pinctrl
+	printk("vfe vfe_request_pin\n");
+	my_dev = dev;
+	//my_pctrl_0 = dev->pctrl;
+	//dev_set_name(&dev->pdev->dev,"twi2");
 	dev_set_name(&dev->pdev->dev,"csi%d",dev->id);
 	if(!IS_ERR_OR_NULL(dev->pctrl))
 	{
 		devm_pinctrl_put(dev->pctrl);
+		printk("vfe vfe_request_pin error\n");
 	}
 	if(1 == enable){
 		dev->pctrl = devm_pinctrl_get_select(&dev->pdev->dev, "default");
@@ -4250,6 +4353,17 @@ static int vfe_request_pin(struct vfe_dev *dev, int enable)
 			vfe_err("vip%d request pinctrl handle for device [%s] failed!\n", dev->id, dev_name(&dev->pdev->dev));
 			return -EINVAL;
 		}
+		//vfe_muxto_i2c();
+		//vfe_muxto_csi();
+		//devm_pinctrl_put(dev->pctrl);
+		//dev_set_name(&dev->pdev->dev,"twi2");
+		//dev_set_name(&dev->pdev->dev,"csi%d",dev->id);
+		//twi_pctrl = devm_pinctrl_get_select(&dev->pdev->dev, "default");
+		//if (IS_ERR_OR_NULL(twi_pctrl)) {
+		//	vfe_err("vip%d request pinctrl handle for device [%s] failed!\n", dev->id, dev_name(&dev->pdev->dev));
+		//	return -EINVAL;
+		//}
+		printk("vfe vfe_request_pin enabled\n");
 	}
 	else
 	{
@@ -4260,13 +4374,20 @@ static int vfe_request_pin(struct vfe_dev *dev, int enable)
 		}
 	}
 	//to uncheat the pinctrl
+	printk("vfe vfe_request_pin done\n");
 	dev_set_name(&dev->pdev->dev,"sunxi_vfe.%d",dev->id);
 	usleep_range(5000, 6000);
+	//writel((volatile void*)0x11332222,(volatile void __iomem*)(0x01c20894));
+	//usleep_range(5000, 6000);
+	//vfe_fix_mux();
+	//vfe_muxto_i2c();
+	printk("vfe vfe_request_pin done done\n");
 #endif
 
 #ifdef FPGA_PIN
 	//pin for FPGA
 	vfe_print("directly write pin config @ FPGA\n");
+	printk("vfe directly write pin config @ FPGA\n");
 	writel((volatile void*)0x33333333,(volatile void __iomem*)(GPIO_REGS_VBASE+0x90));
 	writel((volatile void*)0x33333333,(volatile void __iomem*)(GPIO_REGS_VBASE+0x94));
 	writel((volatile void*)0x03333333,(volatile void __iomem*)(GPIO_REGS_VBASE+0x98));
@@ -4514,7 +4635,9 @@ static int vfe_resource_request(struct platform_device *pdev ,struct vfe_dev *de
 	/* pin resource */
 	/* request gpio */
 	vfe_request_pin(dev, 1);
+	//return 0;
 	vfe_request_gpio(dev);
+	vfe_fix_mux();
 	return 0;
 }
 
@@ -4763,6 +4886,7 @@ static int vfe_sensor_check(struct vfe_dev *dev)
 	int ret = 0;
 	struct v4l2_subdev *sd = dev->sd;
 	vfe_print("Check sensor!\n");
+	printk("vfe_sensor_check 0\n");
 #ifdef CONFIG_ARCH_SUN8IW8P1	
 	return 0;
 #endif
@@ -4770,33 +4894,39 @@ static int vfe_sensor_check(struct vfe_dev *dev)
 #ifdef USE_SPECIFIC_CCI
 	csi_cci_init_helper(dev->vip_sel);
 #endif
+	printk("vfe_sensor_check 1\n");
 	ret = v4l2_subdev_call(sd,core, init, 0);
 	if(dev->power->stby_mode == NORM_STBY){
 		if(ret < 0)
 		{
 			vfe_set_sensor_power_off(dev);
 			ret = -1;
+			printk("vfe_sensor_check 2\n");
 		}
 		else
 		{
 			v4l2_subdev_call(sd,core, s_power, CSI_SUBDEV_STBY_ON);
 			ret = 0;
+			printk("vfe_sensor_check 3\n");
 		}
 	}
 	else// if(dev->power->stby_mode == POWER_OFF)
 	{
 		ret = (ret< 0)?-1:0;
 		vfe_set_sensor_power_off(dev);
+		printk("vfe_sensor_check 4\n");
 	}
 	if(vfe_i2c_dbg == 1)
 	{
 		vfe_print("NOTE: Sensor i2c dbg, it's always power on and register success!..................\n");
 		ret = 0;
 		vfe_set_sensor_power_on(dev);
+		printk("vfe_sensor_check 5\n");
 	}
 #ifdef USE_SPECIFIC_CCI
 	csi_cci_exit_helper(dev->vip_sel);
 #endif
+	printk("vfe_sensor_check 6\n");
 	return ret;
 }
 
@@ -4805,6 +4935,7 @@ static int vfe_sensor_subdev_register_check(struct vfe_dev *dev,struct v4l2_devi
 							struct ccm_config  *ccm_cfg, struct i2c_board_info *sensor_i2c_board)
 {
 	int ret;
+	printk("vfe_sensor_subdev_register_check USE_SPECIFIC_CCI 0\n");
 	ccm_cfg->sd= NULL;
 	ccm_cfg->sd = cci_bus_match(ccm_cfg->ccm, dev->id, sensor_i2c_board->addr);// ccm_cfg->i2c_addr >> 1);
 	if(ccm_cfg->sd)
@@ -4858,28 +4989,55 @@ static int vfe_actuator_subdev_register( struct vfe_dev *dev, struct ccm_config
 
 #else // NOT defind USE_SPECIFIC_CCI
 
+
+static const s64 mt9v034_link_freqs[] = {
+	        13000000,
+		        26600000,
+			        27000000,
+				        0,
+};
+static struct mt9v032_platform_data my_mt9v034_platform_data = {
+	        .clk_pol        = 0,
+		        .link_freqs     = mt9v034_link_freqs,
+			        .link_def_freq  = 26600000,
+};
+
+static struct i2c_board_info __initdata aptina_sensor_i2c_bdi = {
+	               I2C_BOARD_INFO("mt9v032", 0x48),
+		                      .platform_data = &my_mt9v034_platform_data,
+};
+
 static int vfe_sensor_subdev_register_check(struct vfe_dev *dev,struct v4l2_device *v4l2_dev,
 							struct ccm_config  *ccm_cfg, struct i2c_board_info *sensor_i2c_board)
 {
+
+	sensor_i2c_board = &aptina_sensor_i2c_bdi;
+
+	printk("vfe_sensor_subdev_register_check 0, twi_id = %d\n",ccm_cfg->twi_id);
 	struct i2c_adapter *i2c_adap = i2c_get_adapter(ccm_cfg->twi_id);
 	if (i2c_adap == NULL)
 	{
 		vfe_err("request i2c adapter failed!\n");
 		return -EFAULT;
 	}
+	printk("vfe_sensor_subdev_register_check 1\n");
+	//unsigned short addr = 0x48;
 	ccm_cfg->sd = v4l2_i2c_new_subdev_board(v4l2_dev, i2c_adap, sensor_i2c_board, NULL);
 	if (IS_ERR_OR_NULL(ccm_cfg->sd) )
 	{
 		i2c_put_adapter(i2c_adap);
 		vfe_err("Error registering v4l2 subdevice No such device!\n");
+		vfe_print("registered sensor subdev is err 1+!\n");
 		return -ENODEV;
 	}
 	else
 	{
 		vfe_print("registered sensor subdev is OK!\n");
+		printk("vfe_sensor_subdev_register_check 2 OK\n");
 	}
 	update_ccm_info(dev, ccm_cfg);
 	//Subdev register is OK, check sensor init!
+	printk("vfe_sensor_subdev_register_check 3\n");
 	return vfe_sensor_check(dev);
 }
 static int vfe_sensor_subdev_unregister(struct v4l2_device *v4l2_dev,
@@ -4990,69 +5148,82 @@ static struct v4l2_subdev *vfe_sensor_register_check(struct vfe_dev *dev,struct
 {
 	int sensor_cnt,ret, sensor_num;
 	struct sensor_item sensor_info;
+	printk("vfe_sensor_register_check sensor detect start!\n");
 	if(dev->vip_define_sensor_list == 1)
 	{
+		printk("vfe_sensor_register_check 0\n");
 		sensor_num = ccm_cfg->sensor_cfg_ini->detect_sensor_num;
 		if(ccm_cfg->sensor_cfg_ini->detect_sensor_num == 0)	{
 			sensor_num = 1;
 		}
 	} else {
+		printk("vfe_sensor_register_check 0.0\n");
 		sensor_num = 1;
 	}
 	for(sensor_cnt=0; sensor_cnt<sensor_num; sensor_cnt++)
 	{
+		printk("vfe_sensor_register_check 1\n");
 		if(dev->vip_define_sensor_list == 1)
 		{
+			printk("vfe_sensor_register_check 2\n");
 			if(ccm_cfg->sensor_cfg_ini->detect_sensor_num > 0)
 				cpy_ccm_sub_device_cfg(ccm_cfg, sensor_cnt);
 		}
 		if(get_sensor_info(ccm_cfg->ccm, &sensor_info) == 0)
 		{
+			printk("vfe_sensor_register_check 3\n");
 			if(ccm_cfg->i2c_addr != sensor_info.i2c_addr)
 			{
-				vfe_warn("Sensor info \"%s\" i2c_addr is different from sys_config!\n", sensor_info.sensor_name );
+				printk("vfe_sensor_register_check 4\n");
+				printk("vfe Sensor info \"%s\" i2c_addr is different from sys_config!\n", sensor_info.sensor_name );
 				//vfe_warn("Sensor info i2c_addr = %d, sys_config i2c_addr = %d!\n", sensor_info.i2c_addr, ccm_cfg->i2c_addr);
 				//ccm_cfg->i2c_addr = sensor_info.i2c_addr;
 			}
 			if(ccm_cfg->is_bayer_raw != sensor_info.sensor_type)
 			{
-				vfe_warn("Camer detect \"%s\" fmt is different from sys_config!\n", sensor_info_type[sensor_info.sensor_type]);
-				vfe_warn("Apply detect  fmt = %d replace sys_config fmt = %d!\n", sensor_info.sensor_type, ccm_cfg->is_bayer_raw);
+				printk("vfe_sensor_register_check 5\n");
+				printk("vfe Camer detect \"%s\" fmt is different from sys_config!\n", sensor_info_type[sensor_info.sensor_type]);
+				printk("vfe Apply detect  fmt = %d replace sys_config fmt = %d!\n", sensor_info.sensor_type, ccm_cfg->is_bayer_raw);
 				ccm_cfg->is_bayer_raw = sensor_info.sensor_type;
 			}
 			if(sensor_info.sensor_type == SENSOR_RAW)
 			{
+				printk("vfe_sensor_register_check 6\n");
 				ccm_cfg->is_isp_used = 1;
 			}
 			else
 			{
+				printk("vfe_sensor_register_check 6.0\n");
 				ccm_cfg->act_used = 0;
 			}
-			vfe_print("Find sensor name is \"%s\", i2c address is %x, type is \"%s\" !\n",sensor_info.sensor_name,sensor_info.i2c_addr,
+			printk("vfe Find sensor name is \"%s\", i2c address is %x, type is \"%s\" !\n",sensor_info.sensor_name,sensor_info.i2c_addr,
 							sensor_info_type[sensor_info.sensor_type]);
 		}
 		sensor_i2c_board->addr = (unsigned short)(ccm_cfg->i2c_addr>>1);
 		strcpy(sensor_i2c_board->type,ccm_cfg->ccm);
 
-		vfe_print("Sub device register \"%s\" i2c_addr = 0x%x start!\n",sensor_i2c_board->type, ccm_cfg->i2c_addr);
+		printk("vfe Sub device register \"%s\" i2c_addr = 0x%x start!\n",sensor_i2c_board->type, ccm_cfg->i2c_addr);
 		ret = vfe_sensor_subdev_register_check(dev,v4l2_dev,ccm_cfg,sensor_i2c_board);
+		printk("vfe_sensor_register_check 7- ret:%d\n",ret);
 		if( ret == -1)
 		{
-			vfe_sensor_subdev_unregister(v4l2_dev,ccm_cfg,sensor_i2c_board);
-			vfe_print("Sub device register \"%s\" failed!\n",sensor_i2c_board->type);
+			//vfe_sensor_subdev_unregister(v4l2_dev,ccm_cfg,sensor_i2c_board);
+			printk("vfe Sub device register \"%s\" failed!\n",sensor_i2c_board->type);
 			ccm_cfg->sd =NULL;
 			continue;
 		}
 		else if(ret == ENODEV ||ret == EFAULT)
 		{
+			printk("vfe_sensor_register_check 7\n");
 			continue;
 		}
 		else if(ret == 0)
 		{
-			vfe_print("Sub device register \"%s\" is OK!\n",sensor_i2c_board->type);
+			printk("vfe Sub device register \"%s\" is OK!\n",sensor_i2c_board->type);
 			break;
 		}
 	}
+	printk("vfe_sensor_register_check sensor detect end!\n");
 	return ccm_cfg->sd;
 }
 
@@ -5064,7 +5235,7 @@ static void probe_work_handle(struct work_struct *work)
 	struct video_device *vfd;
 	char vfe_name[16] = {0};
 	mutex_lock(&probe_hdl_lock);
-	vfe_print("probe_work_handle start!\n");
+	printk("vfe probe_work_handle start!\n");
 	vfe_dbg(0,"v4l2_device_register\n");
 	if(dev->dev_qty == 0)
 		goto probe_hdl_clk_close;
@@ -5075,12 +5246,12 @@ static void probe_work_handle(struct work_struct *work)
 		goto probe_hdl_free_dev;
 	}
 	dev_set_drvdata(&dev->pdev->dev, (dev));
-	vfe_dbg(0,"v4l2 subdev register\n");
+	printk("vfe v4l2 subdev register\n");
 	/* v4l2 subdev register */
 	dev->is_same_module = 0;
 	for(input_num=0; input_num<dev->dev_qty; input_num++)
 	{
-		vfe_print("v4l2 subdev register input_num = %d\n",input_num);
+		printk("vfe v4l2 subdev register input_num = %d\n",input_num);
 		if(!strcmp(dev->ccm_cfg[input_num]->ccm,""))
 		{
 			vfe_err("Sensor name is NULL!\n");
@@ -5114,9 +5285,9 @@ static void probe_work_handle(struct work_struct *work)
 		}
 #endif
 
-		//dev->dev_sensor[input_num].addr = (unsigned short)(dev->ccm_cfg[input_num]->i2c_addr>>1);
-		//strcpy(dev->dev_sensor[input_num].type,dev->ccm_cfg[input_num]->ccm);
-		vfe_print("vfe sensor detect start! input_num = %d\n",input_num);
+		dev->dev_sensor[input_num].addr = 0x90; //(unsigned short)(dev->ccm_cfg[input_num]->i2c_addr>>1);
+		strcpy(dev->dev_sensor[input_num].type,"mt9v032");//dev->ccm_cfg[input_num]->ccm);
+		printk("vfe sensor detect start! input_num = %d\n",input_num);
 		dev->input = input_num;
 		if(vfe_sensor_register_check(dev,&dev->v4l2_dev,dev->ccm_cfg[input_num],&dev->dev_sensor[input_num],input_num) == NULL)
 		{
@@ -5127,8 +5298,11 @@ static void probe_work_handle(struct work_struct *work)
 		else{
 			dev->device_valid_flag[input_num] = 1;
 		}
+		printk("vfe dev->ccm_cfg[%d]->is_isp_used = %p\n",input_num,dev->ccm_cfg[input_num]->is_isp_used);
+		printk("vfe dev->ccm_cfg[%d]->is_bayer_raw = %p\n",input_num,dev->ccm_cfg[input_num]->is_bayer_raw);
 		if(dev->ccm_cfg[input_num]->is_isp_used && dev->ccm_cfg[input_num]->is_bayer_raw)
 		{
+			printk("vfe read ini info\n");
 			if(read_ini_info(dev,input_num, "/system/etc/hawkview/"))
 			{
 				vfe_warn("read ini info fail\n");
@@ -5143,14 +5317,14 @@ static void probe_work_handle(struct work_struct *work)
 				;//goto probe_hdl_free_dev;
 		}
 		snesor_register_end:
-		vfe_dbg(0,"dev->ccm_cfg[%d] = %p\n",input_num,dev->ccm_cfg[input_num]);
-		vfe_dbg(0,"dev->ccm_cfg[%d]->sd = %p\n",input_num,dev->ccm_cfg[input_num]->sd);
+		printk("vfe dev->ccm_cfg[%d] = %p\n",input_num,dev->ccm_cfg[input_num]);
+		printk("vfe dev->ccm_cfg[%d]->sd = %p\n",input_num,dev->ccm_cfg[input_num]->sd);
 		//    vfe_dbg(0,"dev->ccm_cfg[%d]->ccm_info = %p\n",input_num,&dev->ccm_cfg[input_num]->ccm_info);
 		//    vfe_dbg(0,"dev->ccm_cfg[%d]->ccm_info.mclk = %ld\n",input_num,dev->ccm_cfg[input_num]->ccm_info.mclk);
-		vfe_dbg(0,"dev->ccm_cfg[%d]->power.iovdd = %p\n",input_num,dev->ccm_cfg[input_num]->power.iovdd);
-		vfe_dbg(0,"dev->ccm_cfg[%d]->power.avdd = %p\n",input_num,dev->ccm_cfg[input_num]->power.avdd);
-		vfe_dbg(0,"dev->ccm_cfg[%d]->power.dvdd = %p\n",input_num,dev->ccm_cfg[input_num]->power.dvdd);
-		vfe_dbg(0,"dev->ccm_cfg[%d]->power.afvdd = %p\n",input_num,dev->ccm_cfg[input_num]->power.afvdd);
+		printk("vfe dev->ccm_cfg[%d]->power.iovdd = %p\n",input_num,dev->ccm_cfg[input_num]->power.iovdd);
+		printk("vfe dev->ccm_cfg[%d]->power.avdd = %p\n",input_num,dev->ccm_cfg[input_num]->power.avdd);
+		printk("vfe dev->ccm_cfg[%d]->power.dvdd = %p\n",input_num,dev->ccm_cfg[input_num]->power.dvdd);
+		printk("vfe dev->ccm_cfg[%d]->power.afvdd = %p\n",input_num,dev->ccm_cfg[input_num]->power.afvdd);
 		//    dev->ccm_cfg[input_num]->ccm_info.mclk = MCLK_OUT_RATE;
 		//    dev->ccm_cfg[input_num]->ccm_info.stby_mode = dev->ccm_cfg[input_num]->ccm_info.stby_mode;
 	}
@@ -5177,7 +5351,7 @@ static void probe_work_handle(struct work_struct *work)
 	list_add_tail(&dev->devlist, &devlist);
 
 	dev->vfd = vfd;
-	vfe_print("V4L2 device registered as %s\n",video_device_node_name(vfd));
+	printk("vfe V4L2 device registered as %s\n",video_device_node_name(vfd));
 
 	/*initial video buffer queue*/
 	videobuf_queue_dma_contig_init(&dev->vb_vidq, &vfe_video_qops, NULL, &dev->slock,
@@ -5194,7 +5368,7 @@ static void probe_work_handle(struct work_struct *work)
 	dev->early_suspend.suspend = vfe_early_suspend;
 	dev->early_suspend.resume = vfe_late_resume;
 	register_early_suspend(&dev->early_suspend);
-	vfe_print("register_early_suspend @ probe handle!\n");
+	printk("vfe register_early_suspend @ probe handle!\n");
 #endif
 
 probe_hdl_clk_close:
@@ -5202,27 +5376,27 @@ probe_hdl_clk_close:
 	vfe_clk_close(dev);
 #endif
 
-	vfe_print("probe_work_handle end!\n");
+	printk("vfe probe_work_handle end!\n");
 	mutex_unlock(&probe_hdl_lock);
 	return ;
 
 	probe_hdl_rel_vdev:
 	video_device_release(vfd);
-	vfe_print("video_device_release @ probe_hdl!\n");
+	printk("vfe video_device_release @ probe_hdl!\n");
 	probe_hdl_unreg_dev:
-	vfe_print("v4l2_device_unregister @ probe_hdl!\n");
+	printk("vfe v4l2_device_unregister @ probe_hdl!\n");
 	v4l2_device_unregister(&dev->v4l2_dev);
 	probe_hdl_free_dev:
-	vfe_print("vfe_resource_release @ probe_hdl!\n");
+	printk("vfe vfe_resource_release @ probe_hdl!\n");
 #ifdef USE_SPECIFIC_CCI
 	csi_cci_exit_helper(dev->vip_sel);
 	vfe_clk_close(dev);
 #endif
 	//vfe_resource_release(dev);
-	vfe_print("vfe_exit @ probe_hdl!\n");
+	printk("vfe vfe_exit @ probe_hdl!\n");
 	//vfe_exit();
 
-	vfe_warn("Failed to install at probe handle\n");
+	printk("vfe Failed to install at probe handle\n");
 	mutex_unlock(&probe_hdl_lock);
 	return ;
 }
@@ -5239,6 +5413,7 @@ static int vfe_probe(struct platform_device *pdev)
 	int input_num;
 	unsigned int i;
 
+	printk("\r\nvfe_probe 0\r\n");
 	vfe_dbg(0,"vfe_probe\n");
 
 	/*request mem for dev*/
@@ -5281,6 +5456,11 @@ static int vfe_probe(struct platform_device *pdev)
 	vfe_print("dev->mipi_sel = %d\n",pdata->mipi_sel);
 	vfe_print("dev->vip_sel = %d\n",pdata->vip_sel);
 	vfe_print("dev->isp_sel = %d\n",pdata->isp_sel);
+	printk("\r\nvfe_probe 1\r\n");
+	printk("vfe_probe pdev->id = %d\n",pdev->id);
+	printk("vfe_probe dev->mipi_sel = %d\n",pdata->mipi_sel);
+	printk("vfe_probe dev->vip_sel = %d\n",pdata->vip_sel);
+	printk("vfe_probe dev->isp_sel = %d\n",pdata->isp_sel);
 
 	//to cheat the pinctrl
 	dev_set_name(&dev->pdev->dev,"csi%d",dev->id);
@@ -5301,6 +5481,7 @@ static int vfe_probe(struct platform_device *pdev)
 		dev->vip_define_sensor_list = define_sensor_list;
 	}
 
+	printk("\r\nvfe_probe 2\r\n");
 	ret = fetch_config(dev);
 	if (ret) {
 		vfe_err("Error at fetch_config\n");
@@ -5323,8 +5504,10 @@ static int vfe_probe(struct platform_device *pdev)
 #ifdef USE_SPECIFIC_CCI
 	vfe_clk_open(dev);
 #endif
+	//return 0;
 	//to uncheat the pinctrl
 	dev_set_name(&dev->pdev->dev,"sunxi_vfe.%d",dev->id);
+	printk("\r\nvfe_probe 3\r\n");
 
 	ret = bsp_csi_set_base_addr(dev->vip_sel, (unsigned int)dev->regs.csi_regs);
 	if(ret < 0)
@@ -5356,6 +5539,7 @@ static int vfe_probe(struct platform_device *pdev)
 	}
 #endif
 
+	printk("\r\nvfe_probe 4\r\n");
 	bsp_isp_init_platform(dev->platform_id);
 	bsp_isp_set_base_addr((unsigned int)dev->regs.isp_regs);
 	bsp_isp_set_map_load_addr((unsigned int)dev->regs.isp_load_regs);
@@ -5380,6 +5564,7 @@ static int vfe_probe(struct platform_device *pdev)
 		dev->isp_init_para.isp_src_ch_en[i] = 0;
 	dev->isp_init_para.isp_src_ch_en[dev->id] = 1;
 
+	printk("\r\nvfe_probe 5\r\n");
 	//=======================================
 
 	/* init video dma queues */
@@ -5395,6 +5580,7 @@ static int vfe_probe(struct platform_device *pdev)
 
 	schedule_delayed_work(&dev->probe_work,msecs_to_jiffies(1));
 
+	printk("\r\nvfe_probe 6\r\n");
 	/* initial state */
 	dev->capture_mode = V4L2_MODE_PREVIEW;
 
@@ -5507,6 +5693,7 @@ static int vfe_suspend_helper(struct vfe_dev *dev)
 	dev->vfe_standby_poweroff_flag = 1;
 	vfe_request_pin(dev, 0);
 	vfe_gpio_config(dev, 0);
+	vfe_fix_mux();
 	vfe_disable_regulator_all(dev);
 	vfe_print("vfe_suspend done!\n");
 	return ret;
@@ -5523,6 +5710,7 @@ static void resume_work_handle(struct work_struct *work)
 		goto resume_end;
 	vfe_request_pin(dev, 1);
 	vfe_gpio_config(dev, 1);
+	vfe_fix_mux();
 	if(!IS_ERR_OR_NULL(dev->power) && dev->power->stby_mode == NORM_STBY) {
 
 #ifdef USE_SPECIFIC_CCI
@@ -5744,10 +5932,12 @@ static int __init vfe_init(void)
 	int ret,i;
 	unsigned int vfe_used[MAX_VFE_INPUT];
 
+	printk("\r\nvfe_init 0\r\n");
 #ifdef VFE_SYS_CONFIG
 	script_item_u   val;
 	script_item_value_type_e  type;
 
+	printk("\r\nvfe_init 1\r\n");
 	char vfe_para[16] = {0};
 	for(i=0; i<MAX_VFE_INPUT; i++) {
 		sprintf(vfe_para, "csi%d", i);
@@ -5761,6 +5951,7 @@ static int __init vfe_init(void)
 	}
 #else
 #if defined (CONFIG_ARCH_SUN8IW3P1) || defined(CONFIG_ARCH_SUN8IW5P1) || defined(CONFIG_ARCH_SUN8IW6P1) || defined (CONFIG_ARCH_SUN8IW7P1)
+	printk("\r\nvfe_init 2\r\n");
 	vfe_used[0] = 1;
 	vfe_used[1] = 0;
 #else
@@ -5770,6 +5961,7 @@ static int __init vfe_init(void)
 #endif
 
 	vfe_print("Welcome to Video Front End driver\n");
+	printk("\r\nvfe_init 3\r\n");
 	mutex_init(&probe_hdl_lock);
 	for(i=0; i<MAX_VFE_INPUT; i++) {
 		if(vfe_used[i]) {
@@ -5784,6 +5976,7 @@ static int __init vfe_init(void)
 		return ret;
 	}
 	vfe_print("vfe_init end\n");
+	printk("\r\nvfe_init 4\r\n");
 	return 0;
 }
 
diff --git a/linux-3.4/drivers/media/video/sunxi-vfe/vfe_os.c b/linux-3.4/drivers/media/video/sunxi-vfe/vfe_os.c
index 6ae011d..17ae021 100755
--- a/linux-3.4/drivers/media/video/sunxi-vfe/vfe_os.c
+++ b/linux-3.4/drivers/media/video/sunxi-vfe/vfe_os.c
@@ -2,8 +2,8 @@
 #include <linux/ion_sunxi.h>
 #include "vfe_os.h"
 
-unsigned int vfe_dbg_en = 0;			// set 1 if need debug
-unsigned int vfe_dbg_lv = 1;
+unsigned int vfe_dbg_en = 1;			// set 1 if need debug
+unsigned int vfe_dbg_lv = 0;
 EXPORT_SYMBOL_GPL(vfe_dbg_en);
 EXPORT_SYMBOL_GPL(vfe_dbg_lv);
 
diff --git a/linux-3.4/drivers/media/video/v4l2-common.c b/linux-3.4/drivers/media/video/v4l2-common.c
index 1baec83..3621842 100644
--- a/linux-3.4/drivers/media/video/v4l2-common.c
+++ b/linux-3.4/drivers/media/video/v4l2-common.c
@@ -51,6 +51,7 @@
 #include <linux/string.h>
 #include <linux/errno.h>
 #include <linux/i2c.h>
+//#include <media/mt9v032.h>
 #if defined(CONFIG_SPI)
 #include <linux/spi/spi.h>
 #endif
@@ -304,24 +305,39 @@ EXPORT_SYMBOL_GPL(v4l2_i2c_subdev_init);
 
 
 
+extern struct i2c_client *my_client;
+extern int mt9v032_registered(struct v4l2_subdev *subdev1);
 /* Load an i2c sub-device. */
 struct v4l2_subdev *v4l2_i2c_new_subdev_board(struct v4l2_device *v4l2_dev,
 		struct i2c_adapter *adapter, struct i2c_board_info *info,
-		const unsigned short *probe_addrs)
+		const unsigned short *probe_addr)
 {
 	struct v4l2_subdev *sd = NULL;
 	struct i2c_client *client;
 
 	BUG_ON(!v4l2_dev);
 
+	//adapter = i2c_get_adapter(2);
+
+	printk("v4l2_i2c_new_subdev_board 0!\n");
 	request_module(I2C_MODULE_PREFIX "%s", info->type);
 
+	short probe_addrs[2] = { 0x48, I2C_CLIENT_END };
+
 	/* Create the i2c client */
-	if (info->addr == 0 && probe_addrs)
+	//if (1) {
+	if (info->addr == 0 && probe_addrs) {
 		client = i2c_new_probed_device(adapter, info, probe_addrs,
 					       NULL);
-	else
-		client = i2c_new_device(adapter, info);
+		printk("v4l2_i2c_new_subdev_board 1!\n");
+	}
+	else {
+		//client = i2c_new_device(adapter, info);
+		client = my_client;
+		//client = NULL;
+		//mt9v032_registered(NULL);
+		printk("v4l2_i2c_new_subdev_board 2! i%#x \n", info->addr);
+	}
 
 	/* Note: by loading the module first we are certain that c->driver
 	   will be set if the driver was found. If the module was not loaded
@@ -330,26 +346,35 @@ struct v4l2_subdev *v4l2_i2c_new_subdev_board(struct v4l2_device *v4l2_dev,
 	   loaded. This delay-load mechanism doesn't work if other drivers
 	   want to use the i2c device, so explicitly loading the module
 	   is the best alternative. */
-	if (client == NULL || client->driver == NULL)
+	if (client == NULL || client->driver == NULL) {
+		printk("v4l2_i2c_new_subdev_board 3!\n");
 		goto error;
+	}
 
 	/* Lock the module so we can safely get the v4l2_subdev pointer */
 	if (!try_module_get(client->driver->driver.owner))
 		goto error;
 	sd = i2c_get_clientdata(client);
+	printk("v4l2_i2c_new_subdev_board 4!\n");
 
 	/* Register with the v4l2_device which increases the module's
 	   use count as well. */
-	if (v4l2_device_register_subdev(v4l2_dev, sd))
+	if (v4l2_device_register_subdev(v4l2_dev, sd)) {
 		sd = NULL;
+		printk("v4l2_i2c_new_subdev_board 5!\n");
+	}
 	/* Decrease the module use count to match the first try_module_get. */
 	module_put(client->driver->driver.owner);
+	printk("v4l2_i2c_new_subdev_board 6!\n");
 
 error:
 	/* If we have a client but no subdev, then something went wrong and
 	   we must unregister the client. */
-	if (client && sd == NULL)
-		i2c_unregister_device(client);
+	if (client && sd == NULL) {
+		//i2c_unregister_device(client);
+		printk("v4l2_i2c_new_subdev_board 7!\n");
+	}
+	printk("v4l2_i2c_new_subdev_board 8!\n");
 	return sd;
 }
 EXPORT_SYMBOL_GPL(v4l2_i2c_new_subdev_board);
diff --git a/linux-3.4/drivers/media/video/v4l2-device.c b/linux-3.4/drivers/media/video/v4l2-device.c
index 1f203b8..f1752a1 100644
--- a/linux-3.4/drivers/media/video/v4l2-device.c
+++ b/linux-3.4/drivers/media/video/v4l2-device.c
@@ -146,50 +146,63 @@ int v4l2_device_register_subdev(struct v4l2_device *v4l2_dev,
 #endif
 	int err;
 
+	printk("%s:%d\n", __FUNCTION__,__LINE__);
 	/* Check for valid input */
 	if (v4l2_dev == NULL || sd == NULL || !sd->name[0])
 		return -EINVAL;
 
 	/* Warn if we apparently re-register a subdev */
 	WARN_ON(sd->v4l2_dev != NULL);
+	printk("%s:%d\n", __FUNCTION__,__LINE__);
 
 	if (!try_module_get(sd->owner))
 		return -ENODEV;
+	printk("%s:%d\n", __FUNCTION__,__LINE__);
 
 	sd->v4l2_dev = v4l2_dev;
 	if (sd->internal_ops && sd->internal_ops->registered) {
 		err = sd->internal_ops->registered(sd);
+	printk("%s:%d\n", __FUNCTION__,__LINE__);
 		if (err) {
 			module_put(sd->owner);
+	printk("%s:%d\n", __FUNCTION__,__LINE__);
 			return err;
 		}
+	printk("%s:%d\n", __FUNCTION__,__LINE__);
 	}
-
+	printk("%s:%d\n", __FUNCTION__,__LINE__);
+	
 	/* This just returns 0 if either of the two args is NULL */
 	err = v4l2_ctrl_add_handler(v4l2_dev->ctrl_handler, sd->ctrl_handler);
 	if (err) {
 		if (sd->internal_ops && sd->internal_ops->unregistered)
 			sd->internal_ops->unregistered(sd);
 		module_put(sd->owner);
+	printk("%s:%d\n", __FUNCTION__,__LINE__);
 		return err;
 	}
+	printk("%s:%d\n", __FUNCTION__,__LINE__);
 
 #if defined(CONFIG_MEDIA_CONTROLLER)
 	/* Register the entity. */
 	if (v4l2_dev->mdev) {
+	printk("%s:%d\n", __FUNCTION__,__LINE__);
 		err = media_device_register_entity(v4l2_dev->mdev, entity);
 		if (err < 0) {
 			if (sd->internal_ops && sd->internal_ops->unregistered)
 				sd->internal_ops->unregistered(sd);
 			module_put(sd->owner);
+	printk("%s:%d\n", __FUNCTION__,__LINE__);
 			return err;
 		}
 	}
 #endif
+	printk("%s:%d\n", __FUNCTION__,__LINE__);
 
 	spin_lock(&v4l2_dev->lock);
 	list_add_tail(&sd->list, &v4l2_dev->subdevs);
 	spin_unlock(&v4l2_dev->lock);
+	printk("%s:%d\n", __FUNCTION__,__LINE__);
 
 	return 0;
 }
diff --git a/linux-3.4/drivers/media/video/v4l2-ioctl.c b/linux-3.4/drivers/media/video/v4l2-ioctl.c
index a413bf2..6648033 100755
--- a/linux-3.4/drivers/media/video/v4l2-ioctl.c
+++ b/linux-3.4/drivers/media/video/v4l2-ioctl.c
@@ -517,6 +517,7 @@ static long __video_do_ioctl(struct file *file,
 	long ret_prio = 0;
 	long ret = -ENOTTY;
 
+	//printk("__video_do_ioctl %d cmd: %d\n", VIDIOC_STREAMON, cmd);
 	if (ops == NULL) {
 		printk(KERN_WARNING "videodev: \"%s\" has no ioctl_ops.\n",
 				vfd->name);
diff --git a/linux-3.4/drivers/media/video/videobuf-core.c b/linux-3.4/drivers/media/video/videobuf-core.c
index 304e729..c9f01b1 100755
--- a/linux-3.4/drivers/media/video/videobuf-core.c
+++ b/linux-3.4/drivers/media/video/videobuf-core.c
@@ -297,7 +297,10 @@ enum v4l2_field videobuf_next_field(struct videobuf_queue *q)
 {
 	enum v4l2_field field = q->field;
 
-	BUG_ON(V4L2_FIELD_ANY == field);
+	//BUG_ON(V4L2_FIELD_ANY == field);
+	//printk("ankt videobuf_next_field: %d \n", q->field);
+	if(q->field == V4L2_FIELD_ANY)
+		q->field = V4L2_FIELD_NONE;
 
 	if (V4L2_FIELD_ALTERNATE == field) {
 		if (V4L2_FIELD_TOP == q->last) {
diff --git a/linux-3.4/include/media/mt9v032.h b/linux-3.4/include/media/mt9v032.h
index 5e27f9b..1694ab1 100644
--- a/linux-3.4/include/media/mt9v032.h
+++ b/linux-3.4/include/media/mt9v032.h
@@ -1,12 +1,15 @@
 #ifndef _MEDIA_MT9V032_H
 #define _MEDIA_MT9V032_H
 
-struct v4l2_subdev;
-
+//struct v4l2_subdev;
+//ankt
+//struct i2c_client *my_client;
 struct mt9v032_platform_data {
 	unsigned int clk_pol:1;
 
-	void (*set_clock)(struct v4l2_subdev *subdev, unsigned int rate);
+	//void (*set_clock)(struct v4l2_subdev *subdev, unsigned int rate);
+	const s64 *link_freqs;
+	s64 link_def_freq;
 };
 
 #endif
diff --git a/tools/pack/chips/sun8iw7p1/configs/nanopi-h3/sys_config.fex b/tools/pack/chips/sun8iw7p1/configs/nanopi-h3/sys_config.fex
index 1479e52..a735ac9 100755
--- a/tools/pack/chips/sun8iw7p1/configs/nanopi-h3/sys_config.fex
+++ b/tools/pack/chips/sun8iw7p1/configs/nanopi-h3/sys_config.fex
@@ -151,11 +151,21 @@ twi_used = 1
 twi_scl = port:PA18<3><default><default><default>
 twi_sda = port:PA19<3><default><default><default>
 
+;ankt
 [twi2]
-twi_used = 0
+twi_used = 1
 twi_scl = port:PE12<3><default><default><default>
 twi_sda = port:PE13<3><default><default><default>
 
+;[twi_devices]
+;twi_dev_num = 2
+
+;[twi_board0]
+;modalias = "mt9v032"
+;clk_pol	= 0
+;link_freqs = 
+;link_def_freq = 26600000
+
 [uart0]
 uart_used = 1
 uart_port = 0
@@ -368,16 +378,19 @@ vip_csi_d4               = port:PE08<2><default><default><default>
 vip_csi_d5               = port:PE09<2><default><default><default>
 vip_csi_d6               = port:PE10<2><default><default><default>
 vip_csi_d7               = port:PE11<2><default><default><default>
-vip_csi_sck              = port:PE12<2><default><default><default>
-vip_csi_sda              = port:PE13<2><default><default><default>
-
-vip_dev0_mname           = "ov5640"
+;vip_csi_sck              = port:PE12<2><default><default><default>
+;vip_csi_sda              = port:PE13<2><default><default><default>
+;ankt
+;vip_dev0_mname           = "ov5640"
+;vip_dev0_mname           = 
+vip_dev0_mname           = "mt9v032"
 vip_dev0_pos             = "rear"
 vip_dev0_lane            = 2
-vip_dev0_twi_id          = 2
-vip_dev0_twi_addr        = 0x78
+vip_dev0_twi_id          = 1
+;vip_dev0_twi_addr        = 0x90
+;vip_dev0_twi_addr        = 0x78
 vip_dev0_isp_used        = 0
-vip_dev0_fmt             = 0
+vip_dev0_fmt             = 1
 vip_dev0_stby_mode       = 0
 vip_dev0_vflip           = 0
 vip_dev0_hflip           = 0
